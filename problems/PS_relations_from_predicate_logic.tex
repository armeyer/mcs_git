\documentclass[problem]{mcs}

\newcommand{\discrs}{\ensuremath{\mathcal{D}}}
\newcommand{\vrbls}{\ensuremath{\text{Var}}}

\begin{pcomments}
  \pcomment{PS_relations_from_predicate_logic}
  \pcomment{created by adamc for S12:ps2}
  \pcomment{edited by ARM 1/29/13}
  \pcomment{not in book, still needs a lot of work}
\end{pcomments}

\pkeywords{
  relations
  predicate logic
  environment
  meaning
  sets
  recursive_definition
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem starts here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}

Many mathematical concepts can be expressed with roughly similar
effort either via sets or predicate formulas.  One might wonder
whether there are concepts that can be expressed only one way or the
other.  It may be easy to believe that any description via sets can be
written as a predicate formula as well, since, as we will see in
Chapter~\bref{set_theory_chap}, the axioms of set theory show how the
concepts of set theory can be defined via predicate formulas.  Less
obviously, we can re-express any predicate formula via set theory
operations.  In this problem, you will invent a strategy for this
translation, dealing with a subset of the usual predicate formula
constructs.

In particular, consider predicate formulas built only with the
following constructs:
\begin{itemize}

\item $\mtt{R}(x, y)$, where $\mtt{R}$ is a fixed binary
  relation symbol, and $x$ and $y$ are variables,

\item $\QNOT(\varphi)$, where $\varphi$ is a predicate formula,

\item $\varphi_1 \QAND \varphi_2$ and $\varphi_1 \QOR \varphi_2$,
  where $\varphi_1$ and $\varphi_2$ are predicate formulas,

\item $\forall x. \, \varphi$ and $\exists x. \, \varphi$, where $x$
  is a variable, and $\varphi$ is a formula that may mention $x$.
\end{itemize}

An \term{environment} is what computer scientists call an assignment
of values to variables; logicians call them \term{variable
  assignments}.  Formally, an environment is a
function from the set of variables to their values.  For example,
if $\varphi$ is the formula
\[
x + y = z,
\]
and $\nu_1$ and $\nu_2$ be environments such that
\[\begin{array}{l}
\nu_1(x) = 2, \nu_1(y) = 3, \nu_1(z) = 5,\\
\nu_2(x) = 0, \nu_1(y) = 1, \nu_1(z) = 2,
\end{array}\]
then $\varphi$ is true in environment $\nu_1$ and false in $\nu_2$.

From now on, let's assume there is a fixed domain of discourse,
\discrs, that all variables range over.  So an environment is a
function from the set, \vrbls, of all variables to \discrs.  Let
$\Env$ be set of all such environments.  We will take the relation
symbol $\mtt{R}$ that appears in formulas as the name some given
binary relation $R_\discrs$ on the domain \discrs.

Now we can say that the \index{meaning of a predicate
  formula}\emph{meaning}, $\mean{\varphi}$ of a predicate formula
$\varphi$ is the set of environments in which it is true.

\bparts

\ppart Give a recursive definition of the meaning of any such
predicate formula.

To start you off, here is a rule for the basic formula
$\mtt{R}(x, y)$:
\[
\mean{\mtt{R}(x, y)} \eqdef \set{e \in \Env \suchthat R_\discrs(e(x), e(y))}.
\]

Complete a description of a translation from predicate formulas to set
theory expressions, such that any output expression does not use any
of the predicate logic features that we allow in the input language
beside direct relation applications like $R(x, y)$.

Two more notational conventions will be useful:
\begin{itemize}
\item Use the notation $a[x \leftarrow v]$ to indicate the assignment
  that maps $x$ to $v$ and maps any other variable $y$ to $a(y)$.

\item You are probably used to the notation $\Sigma_{i=1}^n e$ to
  denote the sum of all values of $e$ while variable $i$ ranges from 1
  to $n$.  An alternate notation using set theory is $\Sigma_{i \in S}
  e$ for some set $S$, where we take the sum of $e$ with $i$
  substituted by every element of $S$.  Similar notation $\lgunion_{x
    \in S} e$ and $\lgintersect_{x \in S} e$ will be useful for taking the
  union or intersection, respectively, of all values of $e$ obtained
  by subsituting elements of $S$ for variable $x$.
\end{itemize}

\begin{solution}
  The translation is easily expressed as a \emph{recursive function},
  which you may be familiar with from programming.  We define the
  translation of each formula in terms of the translations of its
  immediate subformulas.
  \begin{eqnarray*}
    T(R(x, y)) &::=& \{ a \in \mathcal A \mid R(a(x), a(y)) \} \\
    T(\QNOT{} \varphi) &::=& \mathcal A - T(\varphi) \\
    T(\varphi_1 \QAND{} \varphi_2) &::=& T(\varphi_1) \cap T(\varphi_2) \\
    T(\varphi_1 \QOR{} \varphi_2) &::=& T(\varphi_1) \cup T(\varphi_2) \\
    T(\forall x. \; \varphi) &::=& \bigcap_{v \in \mathcal D} \{ a \in \mathcal A \mid a[x \leftarrow v] \in T(\varphi) \} \\
    T(\exists x. \; \varphi) &::=& \bigcup_{v \in \mathcal D} \{ a \in \mathcal A \mid a[x \leftarrow v] \in T(\varphi) \}
  \end{eqnarray*}
\end{solution}

\ppart Prove that a predicate formula $\varphi$ is true under
environment $e$ iff $e \in \mean{\varphi}$.

\hint Consider the set of nonnegative integers $n$ such that some
formula $\varphi$ exists where (a) $\varphi$ is $n$ characters long
and (b) $\varphi$ is a counterexample to the claim above.  Derive a
contradiction via the Well Ordering Principle.

\begin{solution}
  Let $C$ be the set of nonnegative integers described in the hint.
  Assume for a contradiction that $C$ is nonempty.  By the WOP, there
  exists a minimal $n \in C$.

  Since $n \in C$, there exist $\varphi$ and $a$ such that $\varphi$
  is $n$ characters long and where we do not have that $a$ satisfies
  $\varphi$ iff $a \in T(\varphi)$.  We proceed with a proof by cases
  over the ways $\varphi$ might be constructed:

  \begin{itemize}

  \item Case $\varphi = \mtt{R}(x, y)$:

\[\begin{array}{rcll}
a \textrm{ satisfies } \varphi &\QIFF{}& R(a(x), a(y))
       & \textrm{(definition of relation formulas)}\\
&\QIFF{}& a \in \set{ a \in \mathcal A \suchthat R(a(x), a(y)) }
       & \textrm{(definition of set builder notation)}\\
&\QIFF{}& a \in T(R(x, y))
       & \textrm{(definition of $T$)}
\end{array}\]

  \item Case $\varphi = \QNOT(\varphi')$:

    Since $\varphi'$ is a subformula of $\varphi$, and since $\varphi$
    contains the character $\QNOT{}$ and $\varphi'$ doesn't, we know
    that $\varphi'$ has a lower character length $n'$ than $\varphi$
    does.  This implies that $n' \not\in C$, since we chose $n$ to be
    the minimum element of $C$.  Therefore, the required equivalence
    holds for $\varphi'$ and any $a$, which we can use to derive the
    equivalence for $\varphi$:
    $$\begin{array}{rcll}
      a \textrm{ satisfies } \varphi &\QIFF{}& \QNOT{} (a \textrm{ satisfies } \varphi') & \textrm{(definition of $\QNOT{}$)} \\
      &\QIFF{}& \QNOT{} (a \in T(\varphi')) \} & \textrm{(equivalence holds for $\varphi'$)} \\
      &\QIFF{}& a \in \mathcal A - T(\varphi') & \textrm{(definition of $-$)} \\
      &\QIFF{}& a \in T(\QNOT{} \varphi') & \textrm{(definition of $T$)} \\
    \end{array}$$

  \item Case $\varphi = \varphi_1 \QAND{} \varphi_2$: \\
    By similar reasoning to above, both $\varphi_1$ and $\varphi_2$ are shorter than $\varphi$, so the equivalence holds for them.
    $$\begin{array}{rcll}
      a \textrm{ satisfies } \varphi &\QIFF{}& (a \textrm{ satisfies } \varphi_1) \QAND{} (a \textrm{ satisfies } \varphi_2) & \textrm{(definition of $\QAND{}$)} \\
      &\QIFF{}& (a \in T(\varphi_1)) \QAND{} (a \in T(\varphi_2)) \} & \textrm{(equivalence holds for $\varphi_1$ and $\varphi_2$)} \\
      &\QIFF{}& a \in T(\varphi_1) \cap T(\varphi_2) & \textrm{(definition of $\cap$)} \\
      &\QIFF{}& a \in T(\varphi_1 \QAND{} \varphi_2) & \textrm{(definition of $T$)}
    \end{array}$$

  \item Case $\varphi = \varphi_1 \QOR{} \varphi_2$: \\
    By similar reasoning to above, both $\varphi_1$ and $\varphi_2$ are shorter than $\varphi$, so the equivalence holds for them.
    $$\begin{array}{rcll}
      a \textrm{ satisfies } \varphi &\QIFF{}& (a \textrm{ satisfies } \varphi_1) \QOR{} (a \textrm{ satisfies } \varphi_2) & \textrm{(definition of $\QOR{}$)} \\
      &\QIFF{}& (a \in T(\varphi_1)) \QOR{} (a \in T(\varphi_2)) \} & \textrm{(equivalence holds for $\varphi_1$ and $\varphi_2$)} \\
      &\QIFF{}& a \in T(\varphi_1) \cup T(\varphi_2) & \textrm{(definition of $\cup$)} \\
      &\QIFF{}& a \in T(\varphi_1 \QOR{} \varphi_2) & \textrm{(definition of $T$)}
    \end{array}$$

  \item Case $\varphi = \forall x. \; \varphi'$: \\
    By similar reasoning to above, $\varphi'$ is shorter than $\varphi$, so the equivalence holds for it.
    $$\begin{array}{rcll}
      a \textrm{ satisfies } \varphi &\QIFF{}& \forall v \in \mathcal D. \; a[x \leftarrow v] \textrm{ satisfies } \varphi' & \textrm{(definition of $\forall$)} \\
      &\QIFF{}& \forall v \in \mathcal D. \; a[x \leftarrow v] \in T(\varphi') & \textrm{(equivalence holds for $\varphi'$)} \\
      &\QIFF{}& a \in \bigcap_{v \in \mathcal D} \{ a' \in \mathcal A \mid a'[x \leftarrow v] \in T(\varphi') \} & \textrm{(definitions of $\bigcap$ and set builder notation)} \\
      &\QIFF{}& a \in T(\forall x. \; \varphi') & \textrm{(definition of $T$)}
    \end{array}$$

  \item Case $\varphi = \exists x. \; \varphi'$: \\
    By similar reasoning to above, $\varphi'$ is shorter than $\varphi$, so the equivalence holds for it.
    $$\begin{array}{rcll}
      a \textrm{ satisfies } \varphi &\QIFF{}& \exists v \in \mathcal D. \; a[x \leftarrow v] \textrm{ satisfies } \varphi' & \textrm{(definition of $\exists$)} \\
      &\QIFF{}& \exists v \in \mathcal D. \; a[x \leftarrow v] \in T(\varphi') & \textrm{(equivalence holds for $\varphi'$)} \\
      &\QIFF{}& a \in \bigcup_{v \in \mathcal D} \{ a' \in \mathcal A \mid a'[x \leftarrow v] \in T(\varphi') \} & \textrm{(definitions of $\bigcup$ and set builder notation)} \\
      &\QIFF{}& a \in T(\exists x. \; \varphi') & \textrm{(definition of $T$)}
    \end{array}$$

  \end{itemize}

  Since every case shows that the desired equivalence holds for
  $\varphi$, we have contradicted our assumption that $C$ is nonempty.
  Therefore, $C$ is empty, and every formula $\varphi$ of every
  character length satisfies the equivalence.
\end{solution}

\eparts

\end{problem}

\endinput
