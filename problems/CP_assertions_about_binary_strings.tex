\documentclass[problem]{mcs}

\begin{pcomments}
  \pcomment{CP_assertions_about_binary_strings}
  \pcomment{from: S09.cp2t, 11.cp2f, F11.cp2f}
\end{pcomments}

\pkeywords{
  translate
  binary strings
  logic_notation
  quantifiers
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem starts here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}
The goal of this problem is to translate some assertions about binary
strings into logic notation.  The domain of discourse is the set of
all finite-length binary strings: $\emptystring$, 0, 1, 00, 01, 10,
11, 000, 001, \ldots.  (Here $\emptystring$ denotes the \idx{empty
  string}.)  In your translations, you may use all the ordinary logic
symbols (including \STR{=}), variables, and the binary symbols
\STR{0}, \STR{1} denoting 0, 1.

A string like $\mathtt{01}x\mathtt{0}y$ of binary symbols and variables
denotes the \emph{concatenation} of the symbols and the binary strings
represented by the variables.  For example, if the value of $x$ is
\STR{011} and the value of $y$ is \STR{1111}, then the value of
$\mathtt{01}x\mathtt{0}y$ is the binary string \STR{0101101111}.

Here are some examples of formulas and their English translations.  Names
for these predicates are listed in the third column so that you can reuse
them in your solutions (as we do in the definition of the predicate
{\sc no-1s} below).

\begin{center}
\begin{tabular}{lclcl}
Meaning &   Formula  & Name \\ \hline
$x$ is a prefix of $y$  & $\exists z\ (xz = y)$ & \sc{prefix}($x, y$) \\
$x$ is a substring of $y$  & $\exists u \exists v\ (uxv = y)$ & \sc{substring}($x, y$) \\
$x$ is empty or a string of 0's\quad  & $\QNOT(\text{\sc{substring}}(\mathtt{1},x))$\quad
  & \sc{no-1s}($x$)
\end{tabular}
\end{center}

\bparts

\ppart $x$ consists of three copies of some string.

\begin{solution}

$\exists y\ (x = yyy)$

\end{solution}

\ppart $x$ is an even-length string of 0's.

\begin{solution}

$\text{\sc{no-1s}}(x) \QAND \exists y\ (x = yy)$

Some students mentioned $\emptystring$ in their formulas.
Technically, this is not allowed, so they need to justify it by giving
a formula that means ``$x = \emptystring$.''  This is easy, for
example: $x = xx$.

A serious mistake was to try writing a recursive definition of a
predicate calculus formula, as in
\begin{equation}\label{recPx00y}
P(x) \eqdef x = \emptystring \QOR \exists y.\, x=00y \QAND P(y).
\end{equation}
Such recursive formulas are, by definition, \emph{not} part of
predicate calculus---with good reason.  Definition~\eqref{recPx00y}
resembles a simple recursive definition of a \emph{procedure} to test
if $x$ is an even length string of \STR{0}'s, and its meaning might be
explained in procedural terms.  But it's hard to figure out in general
what recursively defined formulas mean.  For example, what predicate
is defined by the following ``recursive definition'': $Q(n) \eqdef
\QNOT Q(n)$?

\begin{editingnotes}
A more challenging example is the predicate $P(n)$ that means that
that the integer $n$ is positive.  It is easy to check that $P$
satisfies the following equivalence.
\begin{equation}\label{pniffnn0}
P(n)\ \qiff\ [(n \neq 0) \QAND P(n+1) \QAND P(n-1)] \QOR n = 1.
\end{equation}
Moreover, it is not hard to prove that if $P$ is any predicate that
satisfies~\eqref{pniffnn0} then $P(n)$ holds iff $n > 0$.  In other
words, $P$ is uniquely determined by~\eqref{pniffnn0}.
\[
R(n)\ \qiff\ [(n \neq 0) \QAND R(n+1) \QAND R(n-1)] \QOR n = 1.
\]
\end{editingnotes}

\end{solution}

\ppart $x$ does not contain both a 0 and a 1.

\begin{solution}

\[
\QNOT [\text{\sc{substring}}(\mathtt{0}, x) \QAND \text{\sc{substring}}(\mathtt{1}, x)]
\]

\iffalse
Another solution is
\[
\text{\sc{no-1s}}(x) \disj \text{\sc{no-0s}}(x).
\]
\fi

\end{solution}

\ppart $x$ is the binary representation of $2^k + 1$ for some
integer $k \geq 0$.

\begin{solution}
 $(x = \mathtt{10}) \QOR (\exists y\ (x = \mathtt{1}y\mathtt{1}
\QAND \text{\sc{no-1s}}(y)))$
\end{solution}


\ppart An elegant, slightly trickier way to define $\text{\sc{no-1s}}(x)$
is:
\begin{equation}\tag{*}
\text{\sc{prefix}}(x, \mathtt{0}x).
\end{equation}
Explain why~(*) is true only when $x$ is a string of 0's.

\begin{solution}
Prefixing $x$ with 0 rightshifts all the bits.  So the $n$th symbol of
$x$ shifts into the $(n+1)$st symbol of $0x$.  Now for $x$ to be a
prefix of $0x$, the $(n+1)$st symbol of $0x$, which happens to be the
$n$th symbol of $x$, must match the $(n+1)$st symbol of $x$.
So if $x$ satisfies~(*), the $n$th and $(n+1)$st
symbols of $x$ must match.  This holds for all $n\geq 0$ up to the
length of $x$, that is, \emph{all} the symbols of $x$ must be the
same.  In addition, if $x\neq \emptystring$, it must start with 0.
Therefore, if $x$ satisfies~(*), all its symbols must be 0's.

Note that it's easy to see, conversely, that if $x = \emptystring$ or $x$ is
all 0's, then of course it satisfies~(*).

\begin{staffnotes}
Explain why can't we define ``$x$ is an even-length string of 0's,'' by
\begin{equation}\tag{**}
\text{\sc{prefix}}(x, \mathtt{00}x).
\end{equation}
\end{staffnotes}

\end{solution}

\eparts

\end{problem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem ends here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\endinput
