\documentclass[handout]{mcs}

\begin{document}

\renewcommand{\reading}{Notes Chapters 1--3.}

\problemset{1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problems start here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{problem}
  Week 1, Friday, class problem~\ref{irr-to-irr-by-cases}, proved that the
  were irrational $a,b$ such that $a^b$ was rational.  Unfortunately, that
  proof was \emph{nonconstructive}: it didn't reveal a specific pair,
  $a,b$ with this property.  But in fact, it's easy to do this: let $a
  \eqdef \sqrt{2}$ and $b \eqdef 2\log_2 3$.
  
  We know $\sqrt{2}$ is irrational, and obviously $a^b =3$.  Finish the
  proof that this $a,b$ pair works, by showing that $2\log_2 3$ is
  irrational.

\begin{solution}
\begin{proof}
  Suppose to the contrary that $2\log_2 3$ was rational.  Then $\log_2 3$
  must also be rational, say $\log_2 3 =m/n$ for some positive integers
  $m$ and $n$.  So $m = n\log_2 3$.  Now raising 2 to each side of this
  equation gives
\begin{equation}\label{2m2n3}
2^m = 2^{n \log_2 3} =  2^n\cdot 3.
\end{equation}
But this is impossible, since right hand side of~\eqref{2m2n3} is
divisible by 3 and the left hand side is not.

So $2\log_2 3$ must be irrational.
\end{proof}
\end{solution}
\end{problem}

\iffalse
Show that $\log_{7} n$ is either an integer or irrational, where $n$ is a
positive integer.  Use whatever familiar facts about integers and primes
you need, but explicitly state such facts.  (This problem will be graded
on the clarity and simplicity of your proof.  If you can't figure out how
to prove it, ask the staff for help and they'll tell you how.)

\solution{The statement to be proved is equivalent to the assertion that, for
all positive integers, $n$, if $\log_7 n$ is rational, then it is an
integer.

So we'll assume
\begin{equation}\label{ij}
\log_7 n = \frac{i}{j}
\end{equation}
for some integers, $i,j$.  Now if $i=0$, then $\log_7 n$ is the integer
0, so we can asssume $i>0$ and $n>1$.  Using the fact that $\log_7 x$
is positive for $x>1$, we can conclude that $j> 0$, also.

Now, raising $7$ to the power $\log_7 n$, we have from~\eqref{ij}
\[
n  = 7^{\log_7 n} = 7^{i/j}.
\]
Then, taking $j$th powers,
\begin{equation}\label{nj}
n^j =(7^{i/j})^j =  7^i.
\end{equation}
Since $i,j >0$, both sides of equation~\eqref{nj} are integers.  Also,
since the only prime dividing the righthand of~\eqref{nj} is 7,
\emph{the fact that integers factor uniquely into primes} implies that the
only prime factor of $n^j$, and hence the only prime factor of $n$, is 7.
This means that $n$ can only be a nonnegative power of 7, so $\log_7 n$
must be a nonnegative integer.}
\end{problem}

\fi

\begin{problem}
  In notes Chapter~\ref{pn41}, it took until $n=40$ to find a nonnegative
  integer argument such that $p(n) \eqdef n^2 + n + 41$ was not prime, but
  we could have argued that in general no nonconstant polynomial, $q(n)$,
  with integer coefficients can map each nonnegative integer into a prime
  number.  Prove it.

  \hint Let $c$ be the constant term in $q(n)$.  Consider two cases: $c=0$
  and $c \neq 0$.  In the second case, note that $q(cn)$ is a multiple of
  $c$ for all $n \in \integers$.  You may assume the familiar fact that
  the magnitude (in absolute value) of any nonconstant polynomial, $q(n)$,
  grows unboundedly as $n$ grows.
 
\begin{solution}
%from ARM email reply S07:
\begin{proof}
Suppose $q$ is a polynomial of degree $d$. So
\[
q(n) = \sum_{i=0}^d c_in^i
\]
for some integer constants $c_i$.  Let $c \eqdef c_0$ be the constant term
of $q$.

The proof is by cases following the hint.  

\textbf{Case 1} ($c = 0$): Then all the terms in $q(n)$ are multiples of
$n$, so $p(2m)$ is always even.  Since $q$ is not constant, $\abs{q(2m)}$
grows unboundedly as $m$ increases.  But as soon as $\abs{q(2m)}$
grows bigger than 2, it won't be prime because it has 2 as a factor.

\textbf{Case 2} ($c \neq 0$): In this case, $q(cm)$ has $c$ as a factor
for all integers, $m$.  Because $q$ is not constant, $\abs{q(cm)}$
grows unboundedly as $m$ increases.  But as soon as $\abs{q(2m)}$
grows bigger than $c$, it won't be prime because it has $c$ as a factor.
\end{proof}

\end{solution}

\end{problem}

\pinput{PS_printout_binary_strings}


\begin{problem}
Prove that the propositional formulas
\[
P \QOR Q \QOR R
\]
and
\[
(P \QAND \QNOT Q) \QOR (Q \QAND \QNOT R) \cup (R \QAND \QNOT P) \QOR (P \QAND Q \QAND R).
\]
are equivalent.

\begin{solution}
TBA
\end{solution}
\end{problem}

%unused from S09 cp2m
\begin{problem}
  You saw in a class problem on Monday, Week 2 how to design a simple
  half-adder circuit using propositional formulas.  That design was called
  ``ripple carry'' because the value of the carry from each digit combines
  directly with the following digit, and so the values of the carries
  ripple through all the successive inputs.  In particular, in an $n$-bit
  ripple carry half-adder, there is a path from the first input wire to
  the final carry out of the $n$th digit which goes through at least $n$
  gates,

Considerably faster adder circuits work by computing the values in later
columns for both a carry of 0 and a carry of 1, \emph{in parallel}.  Then
when the carry from the earlier columns finally arrives, the pre-computed
answer can be quickly selected.  We'll illustrate this idea by working out
the equations for an $n+1$-bit parallel half-adder.

Parallel half-adders are built out of parallel ``add1'' modules.  An
$n+1$-bit add1 module takes as input the $n+1$-bit binary representation,
$a_n \dots a_1 a_0$, of an integer, $s$, and produces as output the binary
representation, $c\,p_n\dots p_1\,p_0$, of $s+1$.

\bparts

\ppart A 1-bit add1 module just has input $a_0$.  Write propositional
formulas for its outputs $c$ and $p_0$.

\begin{solution}

\begin{align}
p_0 & = a_0\ \QXOR\ 1 = \QNOT(a_0)\\
c & = a_0.
\end{align}

\end{solution}

\ppart Explain how to build an $n+1$-bit parallel half-adder from an
$n+1$-bit add1 module by writing a propositional formula for the
half-adder output, $o_i$, using only the variables $a_i$, $p_i$, and $b$.

\begin{solution}

\[
o_i  = (b\ \QAND\ p_i)\ \QOR\ (\QNOT(b)\ \QAND\ a_i)
\]

\end{solution}

\eparts

We can build a double-size add1 module with $2(n+1)$ inputs using two
single-size add1 modules with $n+1$ inputs.  Suppose the inputs of the
double-size module are $a_{2n+1},\dots, a_1, a_0$ and the outputs are
$c,p_{2n+1},\dots, p_1,p_0$.  The setup is illustrated in
Figure~\ref{fig:add1}.

Namely, the first single size add1 module handles the first $n+1$ inputs.
The inputs to this module are the low-order $n+1$ input bits $a_n,\dots,
a_1, a_0$, and its outputs will serve as the first $n+1$ outputs $p_n,
\dots, p_1, p_0$ of the double-size module.  Let $c_{(1)}$ be the
remaining carry output from this module.

The inputs to the second single-size module are the higher-order $n+1$
input bits $a_{2n+1}, \dots, a_{n+2}, a_{n+1}$.  Call its first $n+1$
outputs $r_n, \dots, r_1, r_0$ and let $c_{(2)}$ be its carry.

\bparts

\ppart Write a formula for the carry, $c$, in terms of $c_{(1)}$ and
$c_{(2)}$.

\begin{solution}

\[
c = c_{(1)}\ \QAND\ c_{(2)}.
\]

\end{solution}

\ppart Complete the specification of the double-size module by writing
propositional formulas for the remaining outputs, $p_i$, for $n+1 \leq i
\leq 2n+1$.  The formula for $p_i$ should only involve the variables
$a_i$, $r_{i-(n+1)}$, and $c_{(1)}$.

\begin{solution}
 The $n+1$ high-order outputs of the double-size module are the
  same as the inputs if there is no carry from the low-order $n+1$
  outputs, and otherwise is the same as the outputs of the second
  single-size add1 module.  So
\begin{equation}\label{parallel-pi}
p_i = (\QNOT(c_{(1)})\ \QAND\ a_i)\ \QOR\ (c_{(1)}\ \QAND\ r_{i-(n+1)}).
\end{equation}
for $n+1 \leq i \leq 2n+1$.
\end{solution}

\ppart Parallel half-adders are exponentially faster than ripple-carry
half-adders.  Confirm this by determining the largest number of
propositional operations required to compute any one output bit of an
$n$-bit add module.  (You may assume $n$ is a power of 2.)

\begin{solution}
 The most operations for an output are those specified in
  formula~\eqref{parallel-pi}.  So it takes at most 4 additional
  operations to get any one double-size output bit from the single-size
  output bits that it depends on.  It takes $\log_2 n$ doublings to get to
  from 1-bit to $n$-bit modules, so the largest number of operations
  needed for any one output bit is $4 \log_2 n$.

This observation also shows that the \emph{total} number of operations
used in the parallel adder to calculate \emph{all} the output digits is
propositional to $ n \log_2 n$.  This is larger than the total for a
ripple-carry adder by a factor proportional to $\log_2 n$.
\end{solution}

\eparts

\end{problem}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problems end here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
