\documentclass[problem]{mcs}

\begin{pcomments}
  \pcomment{PS_recursive_set_data_type_alt}
  \pcomment{part(b) of PS_recursive_set_data_type}
  \pcomment{ARM 3/8/16, revised 3/9/17, 10/13/17}
  \pcomment{basically a rephrasing of Fundamental Thm for win-lose
    games in the text}
  
\end{pcomments}

\pkeywords{
  set_theory
  recursive_data
  structural_induction
  game
  strategy
}

%\newcommand{\recset}{\text{Recset}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem starts here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}
In this problem, structural induction provides a simple proof about
some utterly infinite objects.

\iffalse

\ppart Show that the collection \recset\ is not, itself, a set.

\hint Use the Foundation Axiom.

\begin{solution}
  Assume \recset\ is a set. Then the constructor case applies to
  \recset\ itself, since all of its members certainly belong to
  \recset, so it follows that $\recset\in\recset$. But no set can be a
  member of itself---this is a consequence of the Foundation axiom,
  described in Section~\bref{avoidingrussellsparadox}. So our
  assumption that \recset\ is a set must be false.

  To see why $S\notin S$ follows from the Foundation axiom (as
  formulated in terms of member-minimal elements), observe that if
  $S\in S$, the singleton set $\{S\}$ has no member-minimal
  element. Indeed, the only candidate is $S$ itself, but this is not
  member minimal because $S\in S$.
\end{solution}

\fi

Every pure set defines a two-person game in which a player's move
consists of choosing any element of the game.  The two players
alternate moves, and a player loses when it is their turn to move and
there is no move to make.  That is, whoever moves to the empty set is
a winner, because the next player has no move.

So we think of a set $R$ as the initial ``board position'' of a
\emph{set game}.  The player who goes first in $R$ is called the
\emph{Next} player, and the player who moves second in $R$ is called
the \emph{Previous} player.  When the Next player moves to an $S \in
R$, the game continues with the new set game $S$ in which the Previous
player moves first.

Prove by structural induction on the Definition~\bref{recset_def} of
recursive sets \recset\ that for every set game, either the Previous
player or the Next player has a winning strategy.\footnote{Set games
  are called ``uniform'' because the two players have the \emph{same}
  objective: to leave the other player stuck with no move to make.  In
  more general games, the two players have different objectives, for
  example, one wants to maximize the final payoff and the other wants
  to minimize it (Problem~\bref{PS_VG}).}
\inhandout{
Reminder:
\begin{definition*}\label{recset_def}
The class of \emph{recursive sets} \recset\ is defined as follows:

\inductioncase{Base case}: The empty set $\emptyset$ is a \recset.

\inductioncase{Constructor step}: If $S$ is a nonempty set of
\recset's, then $S$ is a \recset.
\end{definition*}
By Theorem~\bref{thm_recursive_sets}, every set is recursive.
}

\begin{solution}
Call a set game an \emph{N-game} if the Next player has a winning
strategy and a \emph{P-game} if the Previous player has a winning
strategy.  We prove that every set game $R$ is a P-game or and N-game,
by structural induction on the definition of \recset.

\inductioncase{Base case} ($R = \emptyset$): $R$ is an P-game since
the Next player cannot move.

\inductioncase{Constructor step}: ($R$ is a nonempty set of
\recset's): By structural induction, we may assume that every $s \in
R$ is a P-Game or an N-game.  If there is an $s \in R$ that is a
P-Game, then the Next player wins by picking $s$ (since he will be the
Previous player in $s$), and following the P-winning strategy in $s$.
This makes $R$ an N-game.

Otherwise, every $s \in R$ is an N-game, and the Previous player will
have a winning strategy to follow regardless of which game the Next
player selects.  This makes $R$ a P-game.
\end{solution}

%\eparts

\end{problem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem ends here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\endinput
