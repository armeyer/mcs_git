\documentclass[problem]{mcs}

\begin{pcomments}
  \pcomment{PS_recursive_variable_convention}
  \pcomment{Depends on CP_recursive_prenex}
  \pcomment{draft by ARM 3/7/16}
\end{pcomments}

\pkeywords{
  quantifiers
  predicate_calculus
  logical_formula
  variable
  free_variable
  bound_variable
  unique_variable
  variable_convention
  rename
}

\newcommand{\UV}{\ensuremath{\mathop{\text{UV}}}}
\newcommand{\UVT}{\ensuremath{\mathop{\text{UV}_2}}}
\newcommand{\leftv}{\mathop{\mathrm{left}}}
\newcommand{\rightv}{\mathop{\mathrm{right}}}
\newcommand{\newv}{\ensuremath{\mathop{\mathrm{newvar}}}}
\newcommand{\renm}[3]{\text{renm}({#1},{#2}:={#3})}

%\newcommand{\FV}[1]{\mathop{\text{FV}}(#1)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem starts here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}
In all modern programming languages, re-using the same procedure names
or procedure parameters within different procedure declarations
doesn't cause trouble.  The programming language's ``scoping'' rules
eliminate any ambiguity about which procedure names or procedure
parameters bind to which declarations in any particular context.  It's
always safe to choose whatever names you like, and your procedure will
behave as if your chosen names were unique, and never appeared
elsewhere.

The same thing happens in predicate formulas.\footnote{In fact
  historically, these issues of variable binding scope first came up
  in the study of predicate formulas.}  A variable $x$ may appear at
different places bound by different $\forall x$ or $\exists x$
quantifiers, but there are standard rules for figuring out which
quantifier binds which occurrence of $x$.  In fact, there is a way to
rename variables to make the variable bindings explicit without
changing the meaning of the formula or its structure.  An example of
this was given in Problem~\bref{CP_variable_convention}.

In this problem, we give a recursive definition of a general variable renaming
function \UV\ that converts any predicate formula $F$ into an \emph{equivalent}
formula $\UV(F)$ that satisfies the \emph{unique variable convention}:

\begin{staffnotes}
Equivalence is given to mean \emph{has the same truth value in all
  models}, but we have not gone into details.  Could use of recursive
def of $M \models F$.
\end{staffnotes}

\begin{itemize}

\item For every variable $x$ occurring in $\UV(F)$, there is at most
  one quantified occurrence of $x$, that is, at most one occurrence of
  either ``$\forall x$'' or ``$\exists x$,'' and moreover, ``$\forall
  x$'' and ``$\exists x$'' don't both occur, and

\item if there is a subformula of $\UV(F)$ of the form $\forall x.G$
  or the form $\exists x.G$, then all the occurrences of $x$ that
  appear anywhere in the whole formula are within the subformula.

\end{itemize}

From here on we will ignore the distinction between connective symbols and
propositional operations, for example, between the symbol \ANDsym\ and the
operation \QAND.  We also restrict ourselves to the propositional connectives
\QAND\ and \QNOT.

To define the function \UV, we need an operation that mindlessly
renames variables (free and bound).  We recursively define
$\renm{F}{x}{y}$ to be a mindless renaming of all occurrences of $x$
in $F$ to $y$:

\begin{definition*}
The renaming function, renm, is defined recursively as follows:

For variables $x,y,z$,
\begin{align*}
\renm{x}{x}{y}\ & \eqdef y,\\
\renm{z}{x}{y}\ & \eqdef z
  & \text{(for $z$ different from $x$)}.
\end{align*}

\inductioncase{Base case}: $P(u,\dots,v)$
\[
\renm{P(u,\dots,v)}{x}{y}\ \eqdef P(\renm{u}{x}{y}, \dots, \renm{v}{x}{y}).
\]

\inductioncase{Constructors}:
\begin{align*}
\renm{\QNOT(G)}{x}{y}       &\eqdef \QNOT(\renm{G}{x}{y}),\\
\renm{(G \QAND\ H)}{x}{y}   &\eqdef (\renm{G}{x}{y} \QAND\ \renm{G}{x}{y}),\\
\renm{\forall u.\, G}{x}{y} &\eqdef \forall \renm{u}{x}{y}.\, \renm{G}{x}{y},\\
\renm{\exists u.\, G}{x}{y} &\eqdef \exists \renm{u}{x}{y}.\, \renm{G}{x}{y}.
\end{align*}
\end{definition*}

To define the Unique Variable Convention transform, we will actually need an
auxiliary function \UVT\ that takes two arguments, the formula $F$ to be
converted, and a set $V$ of already-used variables that have to be avoided.
Moreover, $\UVT(F,V)$ will return a \emph{pair} of results: $\leftv(\UVT(F,V))$
will be a converted formula satisfying the unique variable convention, and
$\rightv(\UVT(F,V))$ will be the set $V$ extended with all the variables that
appear in $\leftv(\UVT(F,V))$.  These are the variables which must be avoided
when renaming other formulas.  Then we will define
\[
\UV(F) \eqdef \UVT(F,\emptyset).
\]

Let \newv\ be a function with the property that for any finite set $V$ of
variables, $\newv(V)$ is a ``new'' variable not in $V$.

\begin{definition*}
\inductioncase{Base case}: ($F = P(u,\dots,v)$): 
\begin{align*}
\leftv(\UVT(F,V)) & \eqdef F,\\
\rightv(\UVT(F,V))& \eqdef V \union \set{u,\dots, v}.
\end{align*}

\inductioncase{Constructors}:

Case $(F = \QNOT(G))$:
\begin{align*}
\leftv(\UVT(F,V)) & \eqdef \QNOT(\leftv(\UVT(G,V))),\\
\rightv(\UVT(F,V))& \eqdef \rightv(\UVT(G,V)).
\end{align*}

Case $F = (G \QAND H)$:
Let $V' \eqdef \rightv(\UVT(G,V))$.
\begin{align*}
\leftv(\UVT(F,V)) & \eqdef (\ \leftv(\UVT(G,V)) \QAND\ \leftv(\UVT(H,V'))\ ),\\
\rightv(\UVT(F,V))& \eqdef \rightv(\UVT(H,V')).
\end{align*}

Case $(F = Q\, x.\, G)$ where $Q = \exists, \forall$:

Let $y \eqdef \newv(V)$, $V' \eqdef\ V \union \set{y}$.
\begin{align*}
\leftv(\UVT(F,V)) & \eqdef Q\, y.\, \renm{(\leftv(\UVT(G,V')))}{x}{y},\\
\rightv(\UVT(F,V))& \eqdef \rightv(\UVT(G,V')).
\end{align*}
\end{definition*}

\begin{staffnotes}
Give and then ask for \TBA{examples}.
\end{staffnotes}

\bparts

\ppart A predicate formula defines a property of its free variables, so
converting it to an equivalent formula should leave the same set of free
variables.  Prove that
\[
\fvrbls(F) = \fvrbls(\UVT(F,V))
\]
for all sets of variables $V$.

\ppart Prove that $\UVT(F,V)$ contains no occurrence of any variable in $V$.

\ppart Prove that $\UVT(F,V)$ satisfies the unique variable convention.

\ppart When there is no need to avoid a particular set of variables,
the \UV\ function will convert a formula back into a standard one: prove that
\[
\UV(\UVT(F,V)) = \UV(F)
\]
for all formulas $F$ and sets $V$ of variables.

\eparts

\end{problem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem ends here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\endinput

