\documentclass[problem]{mcs}

\begin{pcomments}
  \pcomment{CP_countable_surjection}
  \pcomment{part(b) of CP_countable_from_surj}
  \pcomment{ARM 12/23/11}
\end{pcomments}

\pkeywords{
  countable
  surjection
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem starts here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}
Prove that if there is a surjective function ($[\leq 1 \text{ out}, \geq 1
  \text{ in}]$ mapping) $f:\nngint \to S$, then $S$ is countable.

\hint A Computer Science proof involves filtering for duplicates.

\begin{solution}
If $S$ is finite, then it is countable by definition, so we can safely
assume that $S$ is infinite.  The function $f$ is not required to be
total, but it is also safe to assume that $f$ is total because we
could always extend $f$ to be total by defining it to be an arbitrary
element of $S$ wherever it might have been undefined.

Now we can think of $f(0), f(1), f(2), \dots$ as a stream of elements
in $S$.  Since $f$ is a surjection, all the elements of $S$ appear in
this sequence, but there may be lots of duplicate occurrences in this
sequence.  If we could find a sequence of the same elements without
duplicates, then we would have the bijection we need.  But it is easy
to filter out the duplicates and get the desired bijection.  Namely,
define $g:\nngint \to S$ recursively by the rules:
\begin{align*}
g(0)   & \eqdef f(0),\\
g(n+1) & \eqdef f(k) & \text{where $k$ is minimum such that}\\
       &             &  f(k) \notin \set{g(0),g(1),\dots,g(n)}.
\end{align*}
If $S$ is infinite, then there always will be an $f(k)$ available to
be the value of $g(n+1)$.  Since all the elements in the sequence
$f(0), f(1), \dots$ still appear in the sequence $g(0), g(1), \dots$,
the function $g$ is a surjection.  Also, all the elements in the
sequence $g(0), g(1), \dots$ are by definition different, so the
function $g$ is also an injection.  This means that $g$ is a bijection
from $\nngint$ to $S$, as required.
\end{solution}

\end{problem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem ends here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\endinput
