\part{Recurrences}\label{part:recurrences}

\partintro
\addcontentsline{toc}{chapter}{Introduction}

A \term{recurrence} describes a sequence of numbers.  Early terms are
specified explicitly, and later terms are expressed as a function of
their predecessors.  As a trivial example, here is a recurrence describing
the sequence $1, 2, 3,\dots$:
\begin{align*}
T_1 & = 1 \\
T_n & = T_{n-1} + 1 & \text{(for $n \geq 2$)}.
\end{align*}
Here, the first term is defined to be 1 and each subsequent term is
one more than its predecessor.

Recurrences turn out to be a powerful tool.  In this chapter, we'll
emphasize using recurrences to analyze the performance of recursive
algorithms.  However, recurrences have other applications in computer
science as well, such as enumeration of structures and analysis of
random processes.  And, as we saw in Section~\ref{book_stacking_sec},
they also arise in the analysis of problems in the physical sciences.

A recurrence in isolation is not a very useful description of a
sequence.  Simple questions such as, ``What is the hundredth term?''
or ``What is the asymptotic growth rate?''  are not in general easy to
answer by inspection of the recurrence.  So a typical goal is to
\emph{solve} a recurrence---that is, to find a closed-form expression
for the $n$th term.

We'll first introduce two general solving techniques:
\term{guess-and-verify} and \term{plug-and-chug}.  These methods are
applicable to every recurrence, but their success requires a flash of
insight---sometimes an unrealistically brilliant flash.  So we'll
also introduce two big classes of recurrences, linear and
divide-and-conquer, that often come up in computer science.
Essentially all recurrences in these two classes are solvable using
cookbook techniques; you follow the recipe and get the answer.  A
drawback is that calculation replaces insight.  The ``Aha!''\ moment
that is essential in the guess-and-verify and plug-and-chug methods is
replaced by a ``Huh'' at the end of a cookbook procedure.

At the end of the chapter, we'll develop rules of thumb to help you
assess many recurrences without any calculation.  These rules can help
you distinguish promising approaches from bad ideas early in the
process of designing an algorithm.

Recurrences are one aspect of a broad theme in computer science:
reducing a big problem to progressively smaller problems until easy
base cases are reached.  This same idea underlies both induction
proofs and recursive algorithms.  As we'll see, all three ideas snap
together nicely.  For example, the running time of a recursive
algorithm could be described with a recurrence with induction used to
verify the solution.

\endinput
