\part{Counting}
\label{part:counting}

\partintro
\addcontentsline{toc}{chapter}{Introduction}

Counting seems easy enough: 1, 2, 3, 4, etc.  This direct approach
works well for counting simple things---like your toes---and may be
the only approach for extremely complicated things with no
identifiable structure.  However, subtler methods can help you count
many things in the vast middle ground, such as:
\begin{itemize}

\item The number of different ways to select a dozen doughnuts when
there are five varieties available.

\item The number of 16-bit numbers with exactly 4 ones.

\end{itemize}
Perhaps surprisingly, but certainly not coincidentally, these two
numbers are the same: 1820.

Counting is useful in computer science for several reasons:
\begin{itemize}

\item
Determining the time and storage required to solve a computational
problem---a central objective in computer science---often comes down
to solving a counting problem.

\item Password and encryption security counts on having a very large
  set of possible passwords and encryption keys.

\item
Counting is the basis of probability theory, which plays a central
role in all sciences, including computer science.

\iffalse

\item
Two remarkable proof techniques, the ``\idx{pigeonhole principle}''
and ``\idx{combinatorial proof},'' rely on counting.
These lead to a variety of interesting and useful insights.
\fi

\end{itemize}


We begin our study of counting in Chapter~\ref{chap:asymptotics} with
a collection of rules and methods for finding closed-form expressions
for commonly-occurring sums and products such as $\sum_{i = 0}^n x^i$
and $\prod_{i=1}^n i$.  We also introduce asymptotic notations
such as $\sim$, $O$ and~$\Theta$ that are commonly used in computer
science to express how a quantity such as the running time of a
program grows with the size of the input.

\iffalse
In Chapter~\ref{chap:recurrences}, we show how to solve a variety of
recurrences that arise in computational problems.  These methods are
especially useful when you need to design or analyze recursive
programs.
\fi

Chapter \ref{counting_chap} describes the most basic rules for determining
the cardinality of a set.  These rules are actually theorems, but our
focus here will be less on their proofs than on teaching their use in
simple counting as a practical skill, like integration.

But counting can be tricky, and people make counting mistakes all the
time, so a crucial part of counting skill is being able to verify a
counting argument.  Sometimes this can be done simply by finding an
alternative way to count and then comparing answers---they better
agree.  But most elementary counting arguments reduce to finding a
bijection between objects to be counted and easy-to-count sequences.
The chapter shows how explicitly defining these bijections---and
verifying that they are bijections---is another useful way to verify
counting arguments.  The material in Chapter \ref{counting_chap} is
simple yet powerful, and it provides a great tool set for use in your
future career.

Finally, Chapter~\ref{generating_function_chap} introduces
\idx{generating functions} which allow many counting problems to be
solved by simple algebraic formula simplification.

\iffalse
We conclude in Chapter~\ref{cardinality_chap} with a brief digression
into the final frontier of counting---infinity.  We'll define what it
means for a set to be countable and show you some examples of sets
that are really big---bigger even than the set of real numbers.
\fi

\endinput
