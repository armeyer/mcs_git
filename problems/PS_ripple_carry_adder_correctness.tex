\documentclass[problem]{mcs}

\begin{pcomments}
  \pcomment{PS_ripple_carry_adder_correctness}
  \pcomment{from S17.ps2}
  \pcomment{S10 by ARM 3/15/10)}
\end{pcomments}

\pkeywords{
  induction
  recursive
  adder
  binary
  specification
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem starts here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}

  For any binary string $\alpha$ let $\binnum{\alpha}$ be the
  nonnegative integer it represents in binary notation (possibly with leading zeroes).  For example,
  $\binnumt{10} = 2$, and $\binnumt{0101} = 5$.

  An \emph{$n+1$-bit adder} adds two $n+1$-bit binary numbers.  More
  precisely, an $n+1$-bit adder takes two length $n+1$ binary strings
  \begin{align*}
    \alpha_n \eqdef a_n\dots a_1 a_0,\\
    \beta_n \eqdef b_n \dots b_1 b_0,
  \end{align*}
  and a binary digit $c_0$ as inputs, and produces a length-($n+1$) binary string
  \[
  \sigma_n \eqdef s_{n} \dots s_{1}s_0,
  \]
  and a binary digit $c_{n+1}$ as outputs, and satisfies the specification:
  \begin{equation}\label{adder-iospec}
    \binnum{\alpha_n} + \binnum{\beta_n} + c_0 = 2^{n+1}c_{n+1} + \binnum{\sigma_n}.
  \end{equation}

  There is a straighforward way to implement an $n+1$-bit adder as a
  digital circuit: an $n+1$-bit \emph{\idx{ripple-carry} circuit} has
  $1+2(n+1)$ binary inputs
\[
a_n,\dots, a_1,a_0,b_n, \dots, b_1,b_0,  c_0,
\]
and $n+2$ binary outputs,
\[
c_{n+1}, s_{n}, \dots, s_{1}, s_{0}.
\]
As in Problem~\bref{CP_binary_adder_logic}, the ripple-carry circuit
is specified by the following formulas:
  \begin{align}
  s_{i} & \eqdef a_{i}\ \QXOR\ b_{i}\ \QXOR\ c_{i} \label{siadddef}\\
  c_{i+1} & \eqdef (a_i\ \QAND\ b_i) \QOR
                  (a_i\ \QAND\ c_i) \QOR
                  (b_i\ \QAND\ c_i) \label{ciadddef}
  \end{align}
for $0 \leq i \leq n$, where we follow the convention that $1$ corresponds to \true\ and $0$ corresponds to \false.

\bparts

\ppart Verify that definitions~\eqref{siadddef} and~\eqref{ciadddef}
imply that
 \begin{equation}\label{anbncn2c}
   a_n + b_n + c_n = 2c_{n+1} + s_n.
 \end{equation}
for all $n \in \nngint$.

\begin{solution}
One way to verify the claim is by filling out the truth table using definitions~\eqref{siadddef} and~\eqref{ciadddef}.
\[
\begin{array}{|l|l|l|l|l|l|l|}
\hline
a_n        & b_n        & c_n        & s_n        & c_{n+1}    & a_n+b_n+c_n    & 2c_{n+1}+s_n \\ \hline
0          & 0          & 0          & 0          & 0          & 0              & 0             \\ \hline
0          & 0          & 1          & 1          & 0          & 1              & 1             \\ \hline
0          & 1          & 0          & 1          & 0          & 1              & 1             \\ \hline
0          & 1          & 1          & 0          & 1          & 2              & 2             \\ \hline
1          & 0          & 0          & 1          & 0          & 1              & 1             \\ \hline
1          & 0          & 1          & 0          & 1          & 2              & 2             \\ \hline
1          & 1          & 0          & 0          & 1          & 2              & 2             \\ \hline
1          & 1          & 1          & 1          & 1          & 3              & 3             \\ \hline
\end{array}
\]
The values in the last two columns are equal, which means that \eqref{anbncn2c} holds for all possible values of $a_n$, $b_n$, and $c_n$.
\end{solution}

\ppart Prove by induction on $n$ that an $n+1$-bit ripple-carry
circuit really is an $n+1$-bit adder, that is, its outputs
satisfy~\eqref{adder-iospec}.

 \hint You may assume that, by definition of binary representation of integers,
 \begin{equation}\label{alphan+1binrep}
   \binnum{\alpha_{n+1}} = a_{n+1}2^{n+1} + \binnum{\alpha_n}.
 \end{equation}

  \begin{solution}
    \begin{proof}
      The proof is by induction on $n$.  The induction hypothesis is
      that an $n+1$-bit ripple carry satisfies~\eqref{adder-iospec}.

      \textbf{Base case:} $(n=0)$.  Thus follows immediately
      from~\eqref{anbncn2c}.

      \textbf{Inductive step:} We assume by induction that an
      $n+1$-bit ripple-carry adder satisfies~\eqref{adder-iospec}, and
      prove that an $n+2$-bit ripple-carry adder will
      satisfy~\eqref{adder-iospec} with ``$n$'' replaced by ``$n+1$,'' namely,
      \begin{equation}\label{n+1adder-iospec}
        \binnum{\alpha_{n+1}} + \binnum{\beta_{n+1}} + c_0
          = c_{n+2}2^{n+2} + \binnum{\sigma_{n+1}}.
      \end{equation}

      We prove~\eqref{n+1adder-iospec} by transforming the left-hand
      side into the right-hand side.
      \begin{align*}
        \lefteqn{\binnum{\alpha_{n+1}} + \binnum{\beta_{n+1}} + c_0}\\
          & = (a_{n+1}2^{n+1} + \binnum{\alpha_n})_ + (b_{n+1}2^{n+1} + \binnum{\beta_n}) + c_0
                & \text{(by~\eqref{alphan+1binrep})}\\
          & = (a_{n+1} + b_{n+1})2^{n+1} + (\binnum{\alpha_n} + \binnum{\beta_n}+c_0)\\
          & = (a_{n+1} + b_{n+1})2^{n+1} + (2^{n+1}c_{n+1} + \binnum{\sigma_n})
                & \text{(by induction hypothesis)}\\
          & = (a_{n+1} + b_{n+1} + c_{n+1})2^{n+1} + \binnum{\sigma_n}\\
          & = (2c_{n+2} + s_{n+1}) 2^{n+1} + \binnum{\sigma_n}
                & \text{(by~\eqref{anbncn2c})}\\
          & = c_{n+2}2^{n+2} + s_{n+1} 2^{n+1} + \binnum{\sigma_{n}}\\
          & = c_{n+2}2^{n+2} + \binnum{\sigma_{n+1}}
                & \text{(by~\eqref{alphan+1binrep})}.
      \end{align*}
      This completes the proof of the inductive step.

      We conclude by induction that for all nonnegative integers $n$
      an $n+1$-bit ripple-carry circuit satisfies~\eqref{adder-iospec}
      and so is a correct implementation of an $n+1$-bit adder.
    \end{proof}
  \end{solution}

\eparts

\end{problem}

\endinput
