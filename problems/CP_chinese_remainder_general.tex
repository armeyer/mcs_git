\documentclass[problem]{mcs}

\begin{pcomments}
  \pcomment{CP_chinese_remainder_general}
  \pcomment{same as PS_chinese_remainder_general w/o restatement of Chinese remainder with two}
  \pcomment{by ARM 3/1/11}
\end{pcomments}

\pkeywords{
  prime
  relatively_prime
  number_theory
  modular_arithmetic
  chinese_remainder
  remainder
  parallel
  residue
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem starts here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}
The general version of the Chinese Remainder
Theorem\inhandout{\footnote{The \term{Chinese Remainder Theorem}
    asserts that if $a, b$ are relatively prime and greater than 1,
    then for all $m,n$, there is a \emph{unique} $x \in
    \Zintvco{0}{ab}$ such that
  \begin{align*}
   x &\equiv m \pmod a,\\
   x &\equiv n \pmod b.
  \end{align*}
See Problem~\bref{CP_chinese_remainder}.}}\inbook{ (see
  Problem~\bref{CP_chinese_remainder})} extends to more than two
relatively prime moduli.  Namely,

\begin{theorem*}[General Chinese Remainder]
Suppose $a_1,\dots,a_k$ are integers greater than 1 and each is
relatively prime to the others.  Let $n \eqdef a_1 \cdot a_2 \cdots
a_k$.  Then for any integers $m_1,m_2,\dots,m_k$, there is a unique $x
\in \Zintvco{0}{n}$ such that
\[
x \equiv m_i \pmod{a_i},
\]
for $1 \le i \le k$.
\end{theorem*}

The proof is a routine induction on $k$ using a fact that follows
immediately from unique factorization: if a number is relatively prime
to some other numbers, then it is relatively prime to their product.

The General Chinese Remainder Theorem is the basis for an efficient
approach to performing a long series of additions and multiplications
on ``large'' numbers.

Namely, suppose $n$ was large, but each of the factors $a_i$ was small
enough to be handled by cheap and available arithmetic hardware units.
Suppose a calculation requiring many additions and multiplications
needs to be performed.  To do a single multiplication or addition of
two large numbers $x$ and $y$ in the usual way in this setting would
involve breaking up the $x$ and $y$ into pieces small enough to be
handled by the arithmetic units, using the arithmetic units to perform
additions and multiplications on (many) pairs of small pieces, and
then reassembling the pieces into an answer.  Moreover, the order in
which these operations on pieces can be performed is contrained by
dependence among the pieces---because of ``carries,'' for example.
And this process of breakup and reassembly has to be performed for
each addition and multiplication that needs to be performed on large
numbers.

Explain how the General Chinese Remainder Theorem can be applied to
perform a long series of additions and multiplications on ``large''
numbers much more efficiently than the usual way described above.

\begin{solution}
Represent any ``large'' number $x \in \Zintvco{0}{n}$ by its
\emph{residue representation}:
\[
(\rem{x}{a_1}, \rem{x}{a_2},\dots, \rem{x}{a_m}).
\]

Notice that if $x$ is represented by $(x_1,x_2,\dots,x_m)$ and likewise $y$ by 
$(y_1,y_2,\dots,y_m)$ then
$x+y$ is represented by
\[
(x_1+y_1,x_2+y_2, \dots, x_m+y_m),
\]
and $x \cdot y$ is represented by
\[
(x_1 \cdot y_1,x_2 \cdot y_2, \dots, x_m \cdot y_m).
\]

By maintaining this residue representation, successive additions and
multiplications of large numbers can be performed by the hardware
units without need to reassemble small pieces back into large numbers
after each operations.  Moreover, operations on the pieces can be
performed \emph{in parallel}.

Doing the calculations using residue representation involves an
initial cost of converting each given ``large'' number $x$ into $k$
``small'' pieces.  This just requires dividing $x$ by each of the
$a_i$.  No further conversions are needed to do all the
multiplications and additions and arrive at the residue representation
of the final answer $v$.

To finish, the residue representation of $v$ must be converted back
into a standard (decimal or binary) representation of $v$.  This
conversion is a little more complicated than the forward conversion of
a large number into its residue representation---it turns out to
require about the same effort as a single multiplication of large
numbers in the usual way---but this backward conversion is done only
once, so its costs will be outweighed by the savings gained sticking
to residue representation throughout the rest of the calculation.
\end{solution}

\begin{editingnotes}
This problem started out aiming to ask for an induction proof of the
General Chinese Remainder Theorem, assuming the Chinese Remainder
Theorem for $k=2$.  Most of the proof appears below, but it turned out
to make a poor problem: the proof is easy but seems very cumbersome to
write out.

\begin{proof}
The proof is by induction on $k \ge 2$, with induction hypothesis,
$P(k)$ being the Theorem as stated.

\textbf{base case} ($k =2$): Given by the $a,b$-version stated at the
start.

\textbf{inductive step}: Suppose $a_1,\dots,a_k, a_{k+1}$ satisfy the
conditions for $P(k+1)$ and let $n_{k+1} \eqdef a_1 \cdot a_2 \cdots
a_k \cdot a_{k+1} = n \cdot a_{k+1}$.  Then given $m_1,\dots,
m_k,m_{k+1}$, we want to prove there is a unique $x \in \Zintvco{0}{n_{k+1}}$
  such that
\begin{equation}\label{aemiaik+1}
x \equiv m_i \pmod{a_i},\quad \text{ for } 1 \le i \le k+1.
\end{equation}
Now by induction hypothesis, there is a unique
$x_k \in \Zintvco{0}{n}$ satisfying the first $k$ congruences.  But $n$ and
  $a_{k+1}$ are relatively prime, so by the original Chinese Remainder
  Theorem, there is a unique $x_{k+1} \in \Zintvco{0}{na_{k+1}}$ such that
\begin{align*}
x_{k+1} \equiv x_k \pmod n,\\
x_{k+1} \equiv m_{k+1} \pmod{a_{k+1}}.
\end{align*}
But for any $c,d > 0$, it follows immediately from the definition of congruence that
\[
y \equiv m \pmod{cd} \qimplies y \equiv m \pmod{c}.
\]
So in particular,
\[
x_{k+1} \equiv x_k \equiv m_i \pmod{a_i}
\]
for $1 \le i \le k$.  Hence, $x_{k+1}$ satisfies~\eqref{aemiaik+1}.

UNIQUENESS ARGUMENT TBA.

\end{proof}
\end{editingnotes}

\end{problem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem ends here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\endinput
