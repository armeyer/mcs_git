\newcommand{\prcef}[3]%
{\textbf{action}: #1\\
\textbf{precondition}: #2\\
\textbf{effect}: #3}
\iffalse

\newcommand{\iocode}[2]%
{\textbf{IOCode}\\
\textbf{group 1}: #1\\
\textbf{group 2}: #2}
\fi

\chapter{Alternating Bit Protocol}

\section{Lynch Notes S07.H11-sm}

We finish with a description and proof sketch for the Alternating Bit
Protocol, a well-known two-process communication protocol.  The
protocol achieves reliable FIFO communication over unreliable
channels.  The unreliable channels may lose or duplicate messages, but
are assumed not to reorder them.  The protocols allow a \textbf{Sender}
process to send a sequence of messages from a message alphabet $M$
to a \textbf{Receiver} process.

The algorithm works as follows.

\textbf{Sender} repeatedly sends the rightmost message in its
\textbf{outgoing-queue} of messages, tagged with a \textbf{tagbit}
that is initially $1$.  When \textbf{Receiver} receives this tagged
message, it sets its \textbf{ackbit} to be the message tag $1$, and
adds the message to the left-hand end of its \textbf{received-msgs}
list.  Then as an acknowledgement, \textbf{Receiver} sends back
\textbf{ackbit} 1 repeatedly.  When \textbf{Sender} gets this
acknowledgement bit, it deletes the rightmost outgoing message in its
queue, sets its \textbf{tagbit} to 0, and begins sending the new
rightmost outgoing message, tagged with \textbf{tagbit}.

\textbf{Receiver}, having already accepted the message tagged with
\textbf{ackbit} $1$, ignores subsequent messages with tag $1$, and
waits until it sees the first message with tag $0$; it adds this
message to the left-hand side of its \textbf{received-msgs} list, sets
\textbf{ackbit} to 0 and acknowledges repeatedly with with
\textbf{ackbit} $0$.  \textbf{Sender} now waits till it gets
acknowledgement bit $0$, then goes on to send the next outgoing
message with tag $1$.  In this way, it alternates use of the tags $1$
and $0$ for successive messages.

We claim that this causes \textbf{Sender} to receive \emph{suffix}
original \textbf{outgoing-msgs} queue.  That is, at any stage in the
process when the the \textbf{outgoing-msgs}

(The fact that \textbf{Sender} actually outputs the entire outgoing
queuee is a \emph{liveness} claim---liveness properties are a
generalization of termination properties.  We'll ignore this issue for
now.)

We formalize the description above as a state whose states consist of:
\begin{tabbing}
XXX\=XXX\= \kill \> $\text{\textbf{outgoing-msgs}}$, a finite sequence of $M$,
whose initial value is called \textbf{all-msgs}\\ \> $\text{\textbf{tagbit}} \in
\set{0, 1}$, initially $1$ \\ \\ \> $\text{\textbf{received-msgs}}$, a finite
sequence of $M$, initially empty\\ \> $\text{\textbf{ackbit}}( \in \set{0, 1}$,
initially $0$ \\ \\ \> $\text{\textbf{msg-channel}}$, a finite sequence of $M
\times \set{0, 1}$, initially empty, \\ \> $\text{\textbf{ack-channel}}$, a
finite sequence of $\set{0, 1}$, initially empty
\end{tabbing}

The transitions are:
\begin{enumerate}
\item[\textbf{SEND:}]

\begin{enumerate}
\item
\prcef{$\text{\textbf{send-msg}}(m,b)$}
{% Pre: 
   $m = \text{\textbf{rightend}}(\text{\textbf{outgoing-msgs}}) \QAND
   b = \text{\textbf{tagbit}}$}
{% Eff: 
   add $(m,b)$ to the left-hand end of $\text{\textbf{msg-channel}}$,
   any number $\geq 0$ of times}

\item
\prcef{$\text{\textbf{send-ack}}(b)$}
{% Pre: 
   $b = \text{\textbf{ackbit}}$}
{% Eff: 
   add $b$ to the right-hand end of $\text{\textbf{ack-channel}}$,
   any number $\geq 0$ of times}
\end{enumerate}

\item[\textbf{RECEIVE:}]

\begin{enumerate}
\item
\prcef{$\text{\textbf{receive-msg}}(m,b)$}
 {% Pre: 
   $(m,b) = \text{\textbf{rightend}}(\text{\textbf{msg-channel}})$}
{% Eff: 
   remove $\text{\textbf{rightend}}$ of $\text{\textbf{msg-channel}}$;\\
   if $b \neq \text{\textbf{ackbit}}$, then
   [add $m$ to the left-hand end of $\text{\textbf{receive-msgs}}$;
   $\text{\textbf{ackbit}} := b$.]}

\item \prcef{$\text{\textbf{receive-ack}}(b)$}
{% Pre: 
   $b = \text{\textbf{leftend}}(\text{\textbf{ack-channel}}()$}
{% Eff: 
   remove $\text{\textbf{leftend}}$ of $\text{\textbf{ack-channel}}$.\\
   if $b = \text{\textbf{tagbit}}$, then
   [remove $\text{\textbf{rightend}}$ of $\text{\textbf{outgoing-msgs}}$ (if nonempty);
   $\text{\textbf{tagbit}} := \bar{\text{\textbf{tagbit}}}$]}
\end{enumerate}

\end{enumerate}

Our goal is to show that when $\text{\textbf{tagbit}} \neq
\text{\textbf{ackbit}}$, then\\
\begin{equation}\label{all-msgs-preserved}
\text{\textbf{outgoing-queue}}\cdot \text{\textbf{received-msgs}} =
\text{\textbf{all-msgs}}.
\end{equation}

This requires three auxiliary invariants.
For the first of these, we need a definition.

Let $\text{\textbf{tag-sequence}}$ be the sequence consisting of bits in
$\text{\textbf{ack-channel}}$, in right-to-left order, 
followed by $\text{\textbf{tagbit}}$, 
followed by the tag components of the elements of
$\text{\textbf{msg-channel}}$, in left-to-right order, 
followed by $\text{\textbf{ackbit}}$. 

{\bf Property 2:}
$\text{\textbf{tag-sequence}}$ consists of one of the following:
\begin{enumerate}
\item
All $0$'s.
\item
All $1$'s. 
\item
A positive number of $0$'s followed by a positive number of $1$'s.
\item
A positive number of $1$'s followed by a positive number of $0$'s.
\end{enumerate}
What is being ruled out by these four cases is the situation where
the sequence contains more than one switch of tag value. 

The fact that Property 2 is an invariant can be proved easily by
induction.  We also need: 

{\bf Property 3:}
If $(m,\text{\textbf{tag}})$ is in $\text{\textbf{msg-channel}}$ then $m =
\text{\textbf{rightend}}(\text{\textbf{outgoing-queue}})$. \\

\begin{proof}
(That Property 3 is an invariant)

By induction, using Property 2. 

Base: Obvious, since no message is in the channel initially. 

Inductive step: It is easy to see that the property is preserved by
$\text{\textbf{send}}_{m,b}$, which adds new messages to $\text{\textbf{channel}}_{1,2}$.
The only other case that could cause a problem is
$\text{\textbf{receive}}(b)_{2,1}$,
which could cause $\text{\textbf{tag}}_1$ to change when there is another message
already in $\text{\textbf{channel}}_{1,2}$ with the same tag. 
But this can't happen, by Property 2 applied before the step -- since
the incoming tag $g$ must be equal to $\text{\textbf{tag}}_1$ in this case,
all the tags in $\text{\textbf{tag-sequence}}$ must be the same.
\end{proof}

Finally, we need that the following counterpart
to~\eqref{all-msgs-preserved}: when $\text{\textbf{tagbit}} =
\text{\textbf{ackbit}}$, then
\begin{equation}\label{all-msgs-preserved2}
\text{\textbf{lefttail}(\textbf{outgoing-queue})}\cdot \text{\textbf{received-msgs}} =
\text{\textbf{all-msgs}},
\end{equation}
where $\text{\textbf{lefttail}}(\textbf{outgoing-queue})$ all but the
rightmost message, if any, in \textbf{outgoing-queue}.

Property 4, part 2, easily implies the goal Property 1.
It also implies that $\text{\textbf{work-buf}}_2$ is always nonempty when 
$\text{\textbf{receive}}(b)_{2,1}$ occurs with equal tags; therefore, the
parenthetical check in the code always works out to be true.

\begin{proof}
(That Property 4 is an invariant)

By induction. 
Base: In an initial state, the tags are unequal, 
$\text{\textbf{work-buf}}_1 = \text{\textbf{buf}}_1$ and $\text{\textbf{buf}}_2$ is empty.  This
suffices to show part 1.  part 2 is vacuous.

Inductive step:
When a $\text{\textbf{send}}$ occurs, the tags and buffers are unchanged, so the
truth of the invariants must be preserved. 
It remains to consider $\text{\textbf{receive}}$ events.

$\text{\textbf{receive}}(m,b)_{1,2}$:

If $b = \text{\textbf{tag}}_2$, nothing happens, so the invariants are
preserved.  So suppose that $b \neq \text{\textbf{tag}}_2$.  Then
Property 2 implies that $b = \text{\textbf{tag}}_1$, and then Property
3 implies that $m$ is the first message on
$\text{\textbf{work-buf}}_1$.  The effect of the transition is to
change $\text{\textbf{tag}}_2$ to make it equal to
$\text{\textbf{tag}}_1$, and to replicate the first element of
$\text{\textbf{work-buf}}22_1$ at the end of $\text{\textbf{buf}}_2$.

The inductive hypothesis implies that, before the step,
$\text{\textbf{buf}}_2 \cdot \text{\textbf{work-buf}}_1 =
\text{\textbf{buf}}_1$.  The changes caused by the step imply that,
after the step $\text{\textbf{tag}}_1 = \text{\textbf{tag}}_2$,
$\text{\textbf{work-buf}}_1$ and $\text{\textbf{buf}}_2$ are nonempty,
$\text{\textbf{head}}(\text{\textbf{work-buf}}_1) =
\text{\textbf{last}}(\text{\textbf{buf}}_2)$ and
$\text{\textbf{buf}}_2 \cdot
\text{\textbf{tail}}(\text{\textbf{work-buf}}_1) =
\text{\textbf{buf}}_1$.  This is as needed.

$\text{\textbf{receive}}(b)_{2,1}$:

The argument is similar to the one for
$\text{\textbf{receive}}(m,b)_{1,2}$.  If $b \neq
\text{\textbf{tag}}_1$, nothing happens so the invariants are
preserved.  So suppose that $b = \text{\textbf{tag}}_1$.  Then
Property 2 implies that $b = \text{\textbf{tag}}_2$, and the step
changes $\text{\textbf{tag}}_1$ to make it unequal to
$\text{\textbf{tag}}44_2$.  The step also removes the first element of
$\text{\textbf{work-buf}}_1$.  The inductive hypothesis implies that,
before the step, $\text{\textbf{work-buf}}_1$ and
$\text{\textbf{buf}}_2$ are nonempty,
$\text{\textbf{head}}(\text{\textbf{work-buf}}_1) =
\text{\textbf{last}}(\text{\textbf{buf}}_2)$, and
$\text{\textbf{buf}}_2 \cdot
\text{\textbf{tail}}(\text{\textbf{work-buf}}_1) =
\text{\textbf{buf}}_1$.  The changes caused by the step imply that,
after the step, $\text{\textbf{tag}}_1 \neq \text{\textbf{tag}}_2$ and
$\text{\textbf{buf}}_2 \cdot \text{\textbf{work-buf}}_1 =
\text{\textbf{buf}}_1$.  This is as needed.
\end{proof}


\endinput
