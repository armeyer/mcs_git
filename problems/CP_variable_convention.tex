\documentclass[problem]{mcs}

\begin{pcomments}
  \pcomment{CP_variable_convention}
  \pcomment{ARM 9/12/13}
\end{pcomments}

\pkeywords{
  quantifiers
  predicate_calculus
  logical_formula
  variable
  free_variable
  bound_variable
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem starts here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}
If the names of procedures or their parameters are used in separate
places, it doesn't really matter if the same variable name happens to
be appear, and it's always safe to change a ``local'' name to
something brand new.  The same thing happens in predicate formulas.

For example, we can rename the variable $x$ in ``$\forall x. P(x)$''
to be ``$y$'' to obtain $\forall y. P(y)$ and these two formulas are
equivalent.  So a formula like
\begin{equation}\label{axpx}
(\forall x. P(x)) \QAND (\forall x. Q(x))
\end{equation}
can be rewritten as the equivalent formula
\begin{equation}\label{aypy}
(\forall y. P(y)) \QAND (\forall x. Q(x)),
\end{equation}
which more clearly shows that the separate occurrences of $\forall x$
in~\eqref{axpx} are unrelated.

\begin{staffnotes}
Point out that the rewriting removes any temptation to ``factor out''
the $\forall x$'s in~\eqref{axpx} and get the \textbf{in}equivalent
formula $\forall x. (P(x) \QAND Q(x))$.
\end{staffnotes}

Renaming variables in this way allows every predicate formula to be
converted into an equivalent formula in which every variable name is
used in only one way.  Specifically, a predicate formula satisfies the
\emph{unique variable convention} if
\begin{itemize}

\item for every variable $x$, there is at most one quantified
  occurrence of $x$, that is, at most one occurrence of either
  ``$\forall x$'' or ``$\exists x$,'' and
  moreover, ``$\forall x$'' and ``$\exists x$'' don't both occur, and

\item if there is a subformula of the form $\forall x.F$ or the form $\exists
  x.F$, then all the occurrences of $x$ that appear anywhere in the
  whole formula are within the formula $F$.

\end{itemize}
So formula~\eqref{axpx} violates the unique variable convention
because ``$\forall x$'' occurs twice, but formula~\eqref{aypy} is OK.

A further example is the formula
\begin{align}
\lefteqn{[\forall x\, \exists y.\, P(x) \QAND Q(x,y)]\ \QIMPLIES} \label{axeyPQR}\\ 
 & \quad  (\exists x.\, R(x,z)) \QOR \exists x\, \forall z.\, S(x,y,w,z).\notag
\end{align}

Formula~\eqref{axeyPQR} violates the unique variable convention
because there are three quantified occurrences of $x$ in the formula,
namely, the initial ``$\forall x$'' and then two occurrences of
``$\exists x$'' later.  It violates the convention in others ways as
well.  For instance, there is an occurrence of $y$ that is not inside
the subformula $\exists y.\, P(x) \QAND Q(y)$.

It turns out that \emph{every} predicate formula can be changed into
an equivalent formula that satisfies the unique variable
convention---just by renaming some of the occurrences of its
variables, as we did when we renamed the first two occurrences of $x$
in~\eqref{axpx} into $y$'s to obtain the equivalent
formula~\eqref{aypy}.

Rename occurrences of variables in~\eqref{axeyPQR} to obtain an
equivalent formula that satisfies the unique variable convention.  Try
to rename as few occurrences as possible.

\begin{solution}
\begin{align*}
\lefteqn{[\forall x\, \exists y_1.\, P(x) \QAND Q(x,y_1)]\ \QIMPLIES}\\ 
 & \quad  (\exists x_1.\, R(x_1,z)) \QOR \exists x_2\, \forall z_1.\, S(x_2,y,w,z_1).
\end{align*}
\end{solution}

A general procedure for converting a predicate formula into unique variable
format is described in Problem~\bref{PS_recursive_variable_convention}.

\iffalse
\ppart \inhandout{\emph{[Supplemental]}} Describe a general procedure for renaming
variables in any predicate formula to obtain an equivalent formula
satisfying the unique variable convention.

\begin{solution}
Proceed recursively:

Make no change to formulas with no quantifiers.
If a formula is of the form $\forall v.\, F$, then recursively rename
variables in $F$ to obtain an equivalent formula $F'$ that satisfies
the convention.  Then $\forall v. F'$ is the desired equivalent of
$\forall v.\, F$.  Likewise for $\exists v.\, F$.

If a formula of the form $F \QOR G$ has quantifiers somewhere, then
recursively rename variables in $F$ and $G$ to equivalent $F', G'$
that satisfy the convention.  Now if a variable that is quantified in
$F'$ also occurs in $G'$, then rename all its occurrences in $F'$ to
something new.  Do this for all such variables and call the result
$F''$.  In the same way, rename all the occurrences of variables that
are quantified in $G'$ to variables that don't occur in $F''$ and call
the result $G''$.  Then $F'' \QOR G''$ is the desired equivalent of $F
\QOR G$.  Other propositional connectives like $\QAND, \QIMPLIES$ are
handled similarly.
\end{solution}
\fi

\end{problem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem ends here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\endinput
