\documentclass[handout]{mcs}

\begin{document}


\begin{problem} 
The \textbf{Fifteen Puzzle} consists of sliding square tiles numbered
$1,\dots,15$ held in a $4\times4$ frame with one empty square.  Any tile
adjacent to the empty square can slide into it.  The
\href{http://theory.lcs.mit.edu/classes/6.042/spring02/}{6.042 Icon} is
based on this puzzle.

The standard initial position is
\[\begin{array}{|c|c|c|c|}
\hline 1 & 2 & 3 & 4\\
\hline 5 & 6 & 7 & 8\\
\hline 9 & 10 & 11 & 12\\
\hline 13 & 14  & 15 &  \\
\hline
\end{array}\]
We would like to reach the target position (known in my youth as ``the
impossible'' --- ARM):
\[\begin{array}{|c|c|c|c|}
\hline 15 & 14 & 13 & 12\\
\hline 11 & 10 & 9 & 8\\
\hline7 & 6 & 5 & 4\\
\hline3 & 2 & 1 & \\
\hline
\end{array}\]

A state machine model of the puzzle has states consisting of a $4\times 4$
matrix with 16 entries consisting of the integers $1,\dots,15$ as well as
one ``empty'' entry---like each of the two arrays above.

The state transitions correspond to exchanging the empty square and an
adjacent numbered tile.  For example, an empty at position $(2,2)$ can
exchange position with tile above it, namely, at position $(1,2)$:
\[\begin{array}{|c|c|c|c|}
\hline n_1 & n_2 & n_3 & n_4\\
\hline n_5 &  & n_6 & n_7\\
\hline n_8  & n_9 & n_{10} & n_{11}\\
\hline n_{12} & n_{13} & n_{14}  & n_{15}\\
\hline
\end{array} \longrightarrow
\begin{array}{|c|c|c|c|}
\hline n_1 &   & n_3 & n_4\\
\hline n_5 & n_2 & n_6 & n_7\\
\hline n_8  & n_9 & n_{10} & n_{11}\\
\hline n_{12} & n_{13} & n_{14}  & n_{15}\\
\hline
\end{array} 
\]

In this problem you will use the invariant method prove that starting
from the initial state, there is no way to reach the target state.

We begin by noting that a state can also be represented as a pair
consisting of two things:
\begin{enumerate}

\item a list of the numbers $1,\dots,15$ in the order in which they
appear---reading rows left-to-right from the top row down, ignoring the
empty square, and

\item the coordinates of the empty square---where the upper left
square has coordinates $(1,1)$, the lower right $(4,4)$.

\end{enumerate}

Let $L$ be such an ordered list of the numbers $1,\dots,15$.  A pair of
integers is an \emph{out-of-order pair} in $L$ when the first element of
the pair both comes \emph{earlier} in the list \emph{and is larger}, than
the second element of the pair.  For example, the list $1,2,4,5,3$ has two
out-of-order pairs: 4,3 and 5,3.  The increasing list $1,2\dots n$ has no
out-of-order pairs.

Representing a state, $S$, as the pair $(L, (i,j))$ described above,
define the \emph{parity} of $S$ to be the mod 2 sum of the number of
out-of-order pairs in $L$ and the row-number, $i$, of the empty
square.

\begin{problemparts}

\problempart Verify that the parity of the initial state and the parity of the
target state are different.


\problempart Show that the parity of a state is invariant under transitions.
Conclude that ``the impossible'' is impossible to reach.


\ppart (optional, extra credit) Show that if two states have the same
parity, then there is a way to get from one to the other.

\end{problemparts}
\end{problem}




\begin{problem} \textbf{Structural Induction}

Suppose we start with a sequence of fully parenthesized arithmetic or
Scheme expressions, and then erase all the alphanumeric characters other
than parentheses.  The result is a string of parentheses which ``match
up''.

For example, erasing non-parenthesis characters from the expression
\texttt{(if (or x y) u v)} leaves the string \texttt{(())}.  Similarly,
erasing non-parentheses from the sequence of three arithmetic expressions
\[
\texttt{(x * x), (y + (3 * (z - 9))), ((x + y) * (u + w))}
\]
leaves the string
\[
\texttt{()((()))(()())}.
\]
On the other hand, even though the string \texttt{())(()} has an equal
number of left and right parentheses, it cannot be obtained by erasing in
this way---because the two middle parentheses don't match up.  Also, no
string of parentheses which begins with a right parenthesis or ends with a
left parenthesis can match up.

We can give an inductive definition of the set, SMU, of ``Strings which
Match Up'', as follows:

\begin{itemize}
\item The empty string (consisting of no parentheses) is an SMU.

\item If $s$ and $t$ are SMU's, then the string $\texttt{(}s\texttt{)}t$
is an SMU.  That is, the new string starts with a left parenthesis which
is followed by the parenthesis characters in the string $s$, followed by a
right parenthesis, followed by the parenthesis characters in the string
$t$.

\end{itemize}


There is a simple test to determine whether a string of parentheses is an
SMU: starting with zero, read the string from left to right adding one for
each left parenthesis and -1 for each right parenthesis.  A string
\emph{counts well} when the count never goes negative and is back to zero
by the end of the string.  Let CW be the set of strings of parentheses
which Count Well.

\begin{problemparts}
\problempart Prove that CW contains SMU by structural induction on the
definition of SMU.

\problempart Conversely, prove that SMU contains CW.

\end{problemparts}
\end{problem}







\begin{problem}
Provide recursive definitions of the following sets and functions:

\begin{problemparts}

\problempart The set $S = \{ 2^a 3^b 5^c \mid a, b, c \in \mathbb{N}
\}$.

\problempart The set $L = \{ (a, b) \in \mathbb{Z} \times \mathbb{Z}
\mid \text{$a + 2b = 3k$ for some $k \in \mathbb{Z}$} \}$.

\problempart The set $\Sigma^*$, which consists of all finite strings
of symbols drawn from the set $\{ p, n, d, q \}$.  (We'll use this set
$\Sigma^*$ in the next three problem parts as well.)

\problempart Recursively define a function $l : \Sigma^* \to
\mathbb{N}$ that maps each string in $\Sigma^*$ to its length.


\problempart Suppose that $p$ stands for penny, $n$ stands for nickel,
$d$ stands for dime, and $q$ stands for quarter.  Recursively define a
function $m : \Sigma^* \to \mathbb{N}$ that maps each string in
$\Sigma^*$ to the monetary value of the corresponding pile of change.


\problempart Recursively define a function $r : \Sigma^* \to \Sigma^*$
that maps each string $\sigma_1 \sigma_2 \ldots \sigma_{n}$ in
$\Sigma^*$ to its reverse:

\[
\sigma_n \sigma_{n-1} \ldots \sigma_1
\]

\end{problemparts}
\end{problem}



\begin{problem}
 A robot named ``Spike'' wanders around a two-dimensional
grid.  He starts out at $(0,0)$ and is allowed to take four different
types of step:

\begin{enumerate}
\item $(+2,-1)$
\item $(+1,-2)$
\item $(+1,+1)$ 
\item $(-3,0)$ 
\end{enumerate}

Thus, for example, Spike might walk as follows.  The types of his
steps are listed above the arrows.

\[
(0,0) \stackrel{1}{\rightarrow}
(2,-1) \stackrel{3}{\rightarrow}
(3,0) \stackrel{2}{\rightarrow}
(4,-2) \stackrel{4}{\rightarrow}
(1,-2) \rightarrow \ldots
\]

Spike's true love, a perky toaster named ``Daisy'', awaits at $(0,2)$.

\begin{problemparts}

\problempart Describe a state machine model of this problem.

\problempart State the most restrictive invariant you can find that
holds for all the states that Spike can reach.

\problempart Will Spike ever find his true love?  Either find a path
from Spike to Daisy or use the Invariant Theorem to prove that no such
path exists.

\end{problemparts}

\end{problem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problems end here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}