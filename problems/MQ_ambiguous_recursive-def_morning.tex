\documentclass[problem]{mcs}

\begin{pcomments}
  \pcomment{MQ_ambiguous_recursive-def_morning}
  \pcomment{subsumed by MQ_ambiguous_recursive_def}
  \pcomment{contributed by ARM 10/18/09}
\end{pcomments}

\pkeywords{
 recursive_data
 matching_parenteses
 ambiguous_definition
}

\newcommand{\MB}[1]{\text{MB}_{#1}}
\newcommand{\lefnum}{\text{numleft}}
\newcommand{\derlen}{\text{two-t}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem starts here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{problem}
\begin{definition*}

  Recursively define the set $\MB{1}$ of strings of ``matching'' brackets
  as follows:

\begin{itemize}

\item \textbf{Base case:} $\emptystring \in\MB{1}$.

\item \textbf{Constructor case:} If $s,t \in\MB{1}$, then
  $\mtt{[}s\mtt{]}t \in \MB{1}$.

\end{itemize}

Recursively define the set $\MB{2}$ of strings of brackets as follows:

\begin{itemize}

\item \textbf{Base case:} $\emptystring \in \MB{2}$.

\item \textbf{Constructor cases:}
\renewcommand{\theenumi}{\roman{enumi}}
\renewcommand{\labelenumi}{(\theenumi)}

\begin{enumerate}

\item If $s$ is in $\MB{2}$, then $\mtt{[}s\mtt{]}$ is in $\MB{2}$.

\item If $s,t \in \MB{2}$, $s\neq \emptystring$, and $t \neq
  \emptystring$, then $st$ is in $\MB{2}$.

\end{enumerate}

\end{itemize}

\end{definition*}

These two definitions both specify the same set of strings, that is, $\MB{1}
= \MB{2}$.

\bparts

\begin{comment}
\ppart To prove that $\MB{1} = \MB{2}$, you could first prove that
\[
\forall r \in \MB{1}.\ r \in \MB{2},
\]
and then prove that
\[
\forall u \in \MB{2}.\ u \in \MB{1}.
\]
Of these two statements, \inbook{indicate}\inhandout{circle} the one
that would be simpler to prove by structural induction directly from
the definitions.

\iffalse
\hint The harder of the two proofs requires first working out an idea like
``good counting'' to find matching brackets.
\fi

\begin{solution}
  It's easy to prove that $\forall r \in \MB{1}.\ r \in \MB{2}$
  by structural induction on $r \in \MB{1}$.

  That's because if $s,t \in \MB{2}$, then it's obvious that
  $\mtt{[}s\mtt{]}t \in \MB{2}$, and this immediately proves the inductive
  step of showing that if $\mtt{[}s\mtt{]}t \in \MB{1}$ then $\mtt{[}s\mtt{]}t \in
  \MB{2}$.

  On the other hand, proving that if $s,t \in \MB{1}$ then $st \MB{1}$ is
  what's needed in the inductive step that if $st \in \MB{2}$ then $st \in
  \MB{1}$.  But proving this requires working out a definition of which
  bracket matches the initial bracket in a string in $\MB{1}$.  We saw how
  to do this using the idea of ``good counting,'' but it took some work.
\end{solution}
\end{comment}

\ppart To prove that $\MB{1} = \MB{2}$, you could first prove that
\[
\MB{1} \subseteq \MB{2},
\]
and then prove that
\[
\MB{2} \subseteq \MB{1}.
\]
Suppose structural induction was being used to prove that $\MB{2}
\subseteq \MB{1}$.  \inbook{Indicate}\inhandout{Circle} the one
predicate below that would fit the format for a structural induction
hypothesis in such a proof.

\begin{itemize}

\item $P_0(s) \eqdef s \in \MB{1}$.

\item $P_1(s) \eqdef s \in \MB{2}$.

\item $P_2(s) \eqdef\ (s \in \MB{1} \QIMPLIES s \in \MB{2})$.

\item $P_3(n) \eqdef  \lnth{s} \leq n \QIMPLIES s \in \MB{1}$.

\item $P_4(n) \eqdef  \lnth{s} \leq n \QIMPLIES s \in \MB{2}$.

\end{itemize}

\begin{solution}
  $\MB{2} \subseteq \MB{1}$ means that $\forall s \in \MB{2}.\ s \in
  \MB{1}$.  To prove this, the only hypothesis above that fits the format
  for a structural induction would be $P_0$ in a structural induction on
  the definition of $\MB{2}$.
\end{solution}

\instatements{\newpage}
\ppart One of these recursive definitions is \emph{ambiguous}.  Verify
this by giving two different derivations for the string "$\mtt{[\ ][\ ][\ ]}$"
according to one of these recursive definitions.

\instatements{\vspace{6in}}

\begin{solution}
  $\MB{2}$ is ambiguous, because "$\mtt{[\ ][\ ][\ ]}" \in \MB{2}$ can be derived
  from the second constructor with $s = \mtt{[\ ]}$ and $t = [\ ][\ ]$, but also
  with $s = \mtt{[\ ][\ ]}$ and $t = [\ ]$.
\end{solution}

\ppart Explain in one or two sentences (preferably one) \emph{why} we need
be concerned about ambiguous recursive definitions.

\instatements{\vspace{2in}}

\begin{solution}

A function defined recursively from an ambiguous definition of a data type
may not be well-defined. For example, the following function:
  
\[\begin{array}{rl}
f(r) & \eqdef \begin{cases}
                   0 & \text{ if } r = \emptystring\\
                   1 + f(s)
                     & \text{ if } r = \mtt{[}s\mtt{]},\\
                   f(s) + 2 \cdot f(t)
                     & \text{ if } r = st\text{ and } s,t \neq \emptystring.
                   \end{cases}
\end{array}\]  

is not well-defined because

\[
5= 3+2\cdot 1 =f([\ ][\ ]\cdot[\ ]) = f([\ ]\cdot[\ ][\ ]) = 1+2\cdot 3 =7.
\]

\end{solution}

% \ppart Ambiguous definitions can lead to ill-defined recursive definitions
% of functions.  Here are apparent definitions of four functions $\lefnum_i$
% and $\derlen_i$
% \iffalse from $\MB{i} \to \nngint$\fi
% based on the recursive definition of $\MB{i}$, for $i=1,2$.  
%\inbook{Indicate}\inhandout{Circle} all the
% apparent definitions which do not, in fact, uniquely determine a function.
% 
% \[\begin{array}{rl}
% \lefnum_1(r)  & \eqdef \begin{cases}
%                    0 & \text{ if } r = \emptystring\\
%                    1 + \lefnum_1(s) + \lefnum_1(t)
%                      & \text{ if } r = \mtt{[}s\mtt{]}t.
%                    \end{cases}\\
% \\
% \lefnum_2(r)  & \eqdef \begin{cases}
%                    0 & \text{ if } r = \emptystring\\
%                    1 + \lefnum_2(s)
%                      & \text{ if } r = \mtt{[}s\mtt{]},\\
%                    \lefnum_2(s) + \lefnum_2(t)
%                      & \text{ if } r = st.
%                    \end{cases}\\
% \\
% \derlen_1(r)  & \eqdef \begin{cases}
%                    0 & \text{ if } r = \emptystring\\
%                    1+ \derlen_1(s) + 2\cdot\derlen_1(t)
%                      & \text{ if } r = \mtt{[}s\mtt{]}t.
%                    \end{cases}\\
% \\
% \derlen_2(r)  & \eqdef \begin{cases}
%                    0 & \text{ if } r = \emptystring\\
%                    1 + \derlen_2(s)
%                      & \text{ if } r = \mtt{[}s\mtt{]},\\
%                    \derlen_2(s) + 2 \cdot \derlen_2(t)
%                      & \text{ if } r = st\text{ and } s,t \neq \emptystring.
%                    \end{cases}
% \end{array}\]
% 
% \begin{solution}
% $\lefnum_1$ and $\derlen_1$ are well-defined because the definition of
% $\MB{1}$ is unambiguous.
% 
% $\derlen_2$ is ill-defined, because
% \[
% 5= 3+2\cdot 1 =\derlen_2([\ ][\ ]\cdot[\ ]) = \derlen_2([\ ]\cdot[\ ][\ ]) = 1+2\cdot 3 =7.
% \]
% 
% $\lefnum_2(r)$ is well-defined because it equals the number of left
% brackets in $r$, which could be proved by structural induction on the
% definition of $\MB{2}$.
% \end{solution}

\eparts

\end{problem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem ends here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\endinput
