%CP_recognizable_sets

\documentclass[problem]{mcs}

\begin{pcomments}
  \pcomment{from: S06.cp2f; revised by ARM 9/20/09}
  \pcomment{needs handy copy of Russell paradox or Theorem~ref{powbig}}
\end{pcomments}

\pkeywords{
  diagonal argument
  Russell paradox
  recognizable
  halting problem
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem starts here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}
Let's refer to a programming procedure (written in your favorite
programming language ---C++, or Java, or Python, \dots) as a \term{string
  procedure} when it is applicable to data of type \texttt{string} and
only returns values of type \texttt{boolean}.  When a string procedure,
$P$, applied to a \texttt{string}, $s$, returns \True, we'll say that $P$
\term{recognizes} $s$.  If $\mathcal{R}$ is the set of strings that $P$
recognizes, we'll call $P$ a \term{recognizer} for $\mathcal{R}$.

\bparts

\ppart\label{odd_numeral} Describe how a recognizer for the set of strings
that are the arabic (decimal) numeral for an odd number would work.  (Even
better, actually write a recognizer procedure in your favorite programming
language).

\begin{solution}
  Of course if your programming language has a commonly built-in
  \texttt{string->number} procedure, this is trivial: when applied to an
  input \texttt{string}, $s$, your procedure applies
  \texttt{string->number} to $s$ and checks that the resulting number is
  odd.  (Better watch out though, how does your built-in procedure handle
  strings with leading zeros? ---the arabic numeral for 170 is
  ``\texttt{170},'' not ``\texttt{00017}.'')

  There's also a simpler approach than writing a general
  \texttt{string->number} procedure.  All the standard programming
  languages have built-in operations for scanning the characters in a
  string.  So simply write a procedure that starts by checking that the
  first character of input $s$ is a decimal digit other than \texttt{0}.
  Then let it scan the remaining characters, checking that each is a
  decimal digit, and that the last digit is odd.

\end{solution}

\eparts

A set of \texttt{string}s is called \emph{recognizable} if
there is a recognizer procedure for it.

When you actually program a procedure, you have to type the program text
into a computer system.  This means that every procedure is described by
some \texttt{string} of typed characters.  If a \texttt{string}, $s$, is
actually the typed description of some string procedure, let's refer to
that procedure as $P_s$.  You can think of $P_s$ as the result of
compiling $s$.\footnote{The string, $s$, and the procedure, $P_s$, have to
  be distinguished to avoid a type error: you can't apply a string to
  string.  For example, let $s$ be the string that you wrote as your
  program to answer part~\eqref{odd_numeral}.  Applying $s$ to a string
  argument, say \texttt{27309}, should throw a type exception; what you
  need to do is apply the procedure $P_s$ to \texttt{27309}.  This should
  result in a returned value \True, since \texttt{27309} is the numeral for
  an odd number.}

In fact, it will be helpful to associate every string, $s$, with a
procedure, $P_s$; we can do this by defining $P_s$ to be some fixed string
procedure ---it doesn't matter which one ---whenever $s$ is not the typed
description of an actual procedure that can be applied to
\texttt{string}s.  The result of this is that we have now defined a total
function, $f$, mapping every \texttt{string}, $s$, to the set, $f(s)$, of
\texttt{string}s recognized by $P_s$.  That is we have a total function,
\begin{equation}\label{f:s-to-Ps}
f: \mtt{string} \to \power(\mtt{string}).
\end{equation}

\bparts

\ppart
Explain why the actual range of $f$ is the set of all recognizable sets of
strings.

\begin{solution}
Since $f(s)$ is the set of strings recogized by $P_s$, everything in
$\range{f}$ is a recogizable set.  Conversely,  every recogizable set is
in $\range{f}$: if $\mathcal{R}$ is a recognizable
set, then by definition, there is a procedure, $P$, that recognizes $R$.  So
if $r$ is the input program from which $P$ was compiled, then
$\mathcal{R} = f(r)$.
\end{solution}

\eparts

This is exactly the set up we need to apply the reasoning behind Russell's
Paradox to define a set that is not in the range of $f$, that is, a set of
strings, $\mathcal{N}$, that is \emph{not} recognizable.

\bparts

\ppart\label{Ps-to-s}
Let
\[
\mathcal{N} \eqdef \set{s \in \mtt{string} \suchthat P_s \text{ applied to
$s$ does not return \True}}.
\]
So for every \texttt{string}, $s$, we have by definition
\begin{equation}\label{Ps}
s \in \mathcal{N} \qiff P_s\text{ applied to $s$ does not return \True}.
\end{equation}

Prove that $\mathcal{N}$ is not recognizable.

\hint Russell's paradox.

\begin{solution}
Assume to the contrary that $\mathcal{N}$ was recognizable by some string
procedure.  This procedure must have a string, $w$, that describes it,
so we have
\begin{equation}\label{Pr}
s \in \mathcal{N} \qiff  P_w\text{ applied to $s$ returns \True},
\end{equation}
for all \texttt{string}'s $s$.

Combining~\eqref{Ps} and ~\eqref{Pr}, we have that for every string, $s$,
\begin{equation}\label{PP}
  P_s\text{ applied to $s$ does not return \True}
  \qiff P_w\text{ applied to $s$ returns \True}.
\end{equation}
Now letting $s$ be $w$ in~\eqref{PP}, we reach the contradiction
\[
P_w\text{ applied to $w$ does not return \True}
\qiff P_w\text{ applied to $w$ returns \True}.
\]

This contradiction implies that the assumption that $\mathcal{N}$ was
recognizable must be false.

Notice that $\mathcal{N}$ could have been described as $\set{s \in
  \texttt{string} \suchthat s \not f(s)}$ for $f$ defined
in~\eqref{f:s-to-Ps}.  Using this description of $\mathcal{N}$, the proof
above would be exactly the same as the proof in the Notes of
Theorem~\ref{powbig} that the powerset of $A$ is strictly bigger than $A$.
\end{solution} 

\ppart Discuss what the conclusion of part~\eqref{Ps-to-s} implies about
the possibility of writing ``program analyzers'' that take programs
as inputs and analyze their behavior.

\begin{solution}
  Lets call a programming procedure ``self-unconscious'' if it does not
  return \True\ when applied to its own textual definition.

  Rephrased informally, the conclusion of part~\eqref{Ps-to-s} says that
  it is logically impossible to design a \emph{general} program analyzer,
  which takes as input the (textual definition) of an arbitrary program,
  and recognizes when the program is self-unconscious.  This implies that
  it is impossible to write a program which does the more general analysis
  of how an arbitrary procedure behaves when applied to some given
  arguments.

  BTW, it \emph{is} feasible to write a general procedure that recognizes
  when an arbitrary input procedure \emph{does} return a value ---the
  general procedure just carries out the computation specified by its
  input and returns \True\ exactly when the procedure it is simulating
  returns a value.  In other words, this general procedure just acts like
  a virtual machine simulator or ``interpreter'' for the programming
  language of its input programs.

  It's also important to recognize that there's no hope of getting around
  this by switching programming languages.  For example, by
  part~\eqref{Ps-to-s}, no C++ program can analyze arbitrary C++ programs,
  and no Java program can analyze Java programs, but you might wonder if a
  language like C++, which allows more intimate manipulation of computer
  memory than Java, might therefore allow a C++ program to analyze general
  Java programs.  But there is no loophole here: since it's possible to
  write a Java program that is a simulator/interpreter for C++ programs,
  if a C++ program could analyze Java programs, so could the Java program
  that simulated the C++ program, contradicting~\eqref{Ps-to-s}.
  
  It's a different story if we think about the \emph{practical}
  possibility of writing programming analyzers.  The fact that it's
  logically impossible to write analyzers for completely general programs
  does not mean that you can't do a very good job analyzing interesting
  programs that come up in practice.  In fact these ``interesting''
  programs are commonly \emph{intended} to be analyzable in order to
  confirm that they do what they're supposed to do.

  So it's not clear how much of a hurdle this theoretical limitation
  implies in practice.  What the theory does provide is some perspective
  on claims about general analysis methods for programs.  The theory tells
  us that people who make such claims either

\begin{itemize}
\item are exaggerating the power (if any) of their methods ---say to get a
  grant or make a sale, or

\item are trying to keep things simple by not going into technical
  limitations they're aware of, or

\item perhaps most commonly, are so excited about some useful practical
    successes of their methods, that they haven't bothered to think about
    their limitations.
\end{itemize}  

So from now on, if you hear people making claims about completely general
program analysis/verification/optimization methods, you'll know they can't
be telling the whole story.
\end{solution}

\eparts

\end{problem}

\endinput
