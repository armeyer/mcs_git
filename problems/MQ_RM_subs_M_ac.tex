\documentclass[problem]{mcs}

\begin{pcomments}
  \pcomment{MQ_RM_subs_M}
  \pcomment{used on MQ-3-2-11}
  \pcomment{overlaps with MQ_ambiguous_recursive_def}
  \pcomment{subsumed by PS_RM_equal_AM}
  \pcomment{adapted from PS_M_equal_RM 2/28/11 by Joliat & Kazerani}
  \pcomment{edited by ARM 3/1/11}
\end{pcomments}

\pkeywords{
  string
  matched
  bracket
  structural_induction
  induction
  concatenation
  ambiguous
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem starts here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}

The set $M$ of strings of brackets is recursively defined as follows:

\textbf{Base case:} $\emptystring \in M$.

\textbf{Constructor cases:} If $s,t \in M$, then
\begin{itemize}

\item $\lefbrk s\, \rhtbrk \in M$, and

\item $s\cdot t \in M$.

\end{itemize}
The set $\RM$ of strings of matched brackets was defined recursively
in class.  Recall the definition:

\textbf{Base case:} $\emptystring \in\RM$.

\textbf{Constructor case:} If $s,t \in\RM$, then
$\lefbrk s\, \rhtbrk t \in \RM$.\\\\
Fill in the following parts of a proof by structural induction that
\begin{equation}\label{rmsseqm}
\RM \subseteq M.
\end{equation}

\bparts

\ppart State an \textbf{induction hypothesis} suitable for
proving~\eqref{rmsseqm} by structural induction.

\begin{solution}

\[
P(x) \eqdef x \in M
\]

\end{solution}

\examspace[1in]

\ppart State and prove the \textbf{base case(s)}.

\begin{solution}

\textbf{Base case} ($x = \emptystring$): By definition of $M$, the empty string is in $M$.  

\end{solution}

\examspace[2in]

\ppart Prove the \textbf{inductive step}.

\begin{solution}
\begin{proof}

\textbf{Constructor case} ($x = \lefbrk s\, \rhtbrk t$ for $s,t \in
\RM$): By structural induction hypothesis, we may assume that $s, t
\in M$.  By the first constructor case of $M$, it follows that $[s]
\in M$.  Then, by the second constructor case of $M$, it follows that
$\lefbrk s\, \rhtbrk t \in M$.

\end{proof}

\end{solution}

\examspace[3in]

\eparts

\end{problem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem ends here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\endinput
