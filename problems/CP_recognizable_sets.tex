%CP_recognizable_sets

\documentclass[problem]{mcs}

\begin{pcomments}
  \pcomment{from: S06.cp2f; revised by ARM 9/20/09}
  \pcomments{needs Russell paradox in Appendix}
\end{pcomments}

\pkeywords{
  diagonal argument
  Russell paradox
  recognizable
  halting problem
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem starts here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}
\bparts

Let's refer to a programming procedure (written in your favorite
programming language ---C++, or Java, or Python, \dots) as a \term{string
  procedure} when it is applicable to data of type \texttt{string} and
only returns values of type \texttt{boolean}.  When a string procedure,
$P$, applied to a \texttt{string}, $s$, returns, \true, we'll say that $P$
\term{recognizes} $s$.  If $\mathcal{R}$ is the set of strings that $P$
recognizes, we'll call $P$ a \term{recognizer} for $\mathcal{R}$.

\ppart Describe how a string procedure could recognize the set of strings
that are the arabic (decimal) numeral for an odd number.  (Even better,
actually write such a procedure in your favorite programming language).

\begin{solution}
  Of course if your programming language has a built-in
  \texttt{string->number} procedure, this is trivial: when applied to an
  input \texttt{string}, $s$, your procedure applies
  \texttt{string->number} to $s$ and checks that the resulting number is
  even.

  Now not many languages have such a \texttt{string->number} procedure,
  but it woudn't be hard to write such a procedure and then to use it as
  above.

  There's also a simpler approach than writing a general
  \texttt{string->number} procedure.  All the standard programming
  languages have built-in operations for scanning the characters in a
  string.  So simply write a procedure that starts by checking that the
  first character of input $s$ is a decimal digit other than \texttt{0}.
  Then let it scan the remaining characters, checking that each is a
  decimal digit, and that the last digit is odd.

\end{solution}

\eparts

A set of \texttt{string}s is called \emph{recognizable} if
there is a recognizer procedure for it.

When you actually program a procedure, you have to type the program text
into a computer system.  This means that every procedure is described by
some \texttt{string} of typed characters.  If a \texttt{string}, $s$, is
actually the typed description some string procedure, let's refer to that
procedure as $P_s$.

In fact, it will be helpful to associate every string, $s$, with a
procedure, $P_s$; we can do this by defining $P_s$ to be some fixed string
procedure ---it doesn't matter which one ---whenever $s$ is not the typed
description of an actual \texttt{string} procedure.

We're going to define a set, $\mathcal{N}$, of strings that is \emph{not}
recognizable.  The definition of $\mathcal{N}$ is based on the proof of
Rusell's Paradox, and involves applying string procedures to \emph{their
  own descriptions}.

\bparts

\ppart\label{Ps-to-s}
Let
\[
\mathcal{N} \eqdef \set{s \in \mtt{string} \suchthat P_s \text{ applied to
$s$ does not return \true}}.
\]
So for every \texttt{string}, $s$, we have by definition
\begin{equation}\label{Ps}
s \in \mathcal{N} \qiff P_s\text{ applied to $s$ does not return \true}.
\end{equation}

Prove that $\mathcal{N}$ is not recognizable.

\hint Russell's paradox.

\begin{solution}
Assume to the contrary that $\mathcal{N}$ was recognizable by some string
procedure.  This procedure must have a string, $w$, that describes it,
so we have
\begin{equation}\label{Pr}
s \in \mathcal{N} \qiff  P_w\text{ applied to $s$ returns \true},
\end{equation}
for all \texttt{string}'s $s$.

Combining~\eqref{Ps} and ~\eqref{Pr}, we have that for every string, $s$,
\begin{equation}\label{PP}
  P_s\text{ applied to $s$ does not return \true}
  \qiff P_w\text{ applied to $s$ returns \true}.
\end{equation}
Now letting $s$ be $w$ in~\eqref{PP}, we reach the contradiction
\[
P_w\text{ applied to $w$ does not return \true}
\qiff P_w\text{ applied to $w$ returns \true}.
\]

This contradiction implies that the assumption that $\mathcal{N}$ was
recognizable must be false.
\end{solution} 

\ppart Discuss what the conclusion of part~\eqref{Ps-to-s} implies about
the possibility of writing ``program analyzers'' that take programs
as inputs and analyze their behavior.

\begin{solution}
TBA
\end{solution}

\eparts

\end{problem}

\endinput
